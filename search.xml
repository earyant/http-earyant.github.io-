<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[求m的n次方]]></title>
      <url>/2017/10/24/%E6%B1%82m%E7%9A%84n%E6%AC%A1%E6%96%B9/</url>
      <content type="html"><![CDATA[<h2 id="初步设想"><a href="#初步设想" class="headerlink" title="初步设想"></a>初步设想</h2><p>  最简单的方法，就是for循环一下。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> result = <span class="number">1L</span>;</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">     result *= m;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  这种方法结果肯定正确，但是时间复杂度上，需要O(n)。很是不理想。于是我想着改进一下。</p>
<h2 id="探求乘法原理"><a href="#探求乘法原理" class="headerlink" title="探求乘法原理"></a>探求乘法原理</h2><p>  乘法原理就是n个m相乘，例如m=10，n=5， 那么表达式为 10<em>10</em>10<em>10</em>10,有人说这不是废话嘛，当然不是，之所以展开，是因为可以改写法，如：(10<em>10)</em> (10<em>10)</em> 10,又有人说了，这不是还是废话嘛，别急往下看，你会发现(10*10)重复了。</p>
<p>  什么意思？</p>
<p>  如果单纯用for循环10的4次幂，需要 <em>循环4次运算</em>，现在我先用10<em>10,</em>第1次运算<em>，再用得出的结果乘以得出的结果，也就是(10</em>10)<em> (10</em>10),<em>第2次运算</em>。就这么简单，此次运算节省了2次，节省了百分之50啊，重大发现啊。</p>
<p>  如果是10的8次幂呢？单纯for循环需要8次，新的方法需要几次？<em>3次</em>。怎么算的？(10<em>10)</em> (10<em>10)</em> (10<em>10)</em> (10<em>10)。发现就是算10</em>10的4次方，算出10<em>10需要 </em>第一次*，4次方刚刚算了是2次，一共是3次，这么神奇啊，节省了5次运算啊。这是节省了百分之。。。ummmm，管他百分之多少呢，反正很多。</p>
<p>  照这么下去，16次方需要 <em>4</em> 次运算，32次方需要 <em>5</em> 次运算，64次方需要 <em>6</em> 次运算，重大发现，也就是说，<em>如果n是2的i次幂，那么就需要i次运算就可以算出m的n次方了。</em></p>
<p>  天晴了， 世界和平了，我又拯救了世界了，可以回家睡懒觉了。</p>
<p>  咦，等等，如果n不是2的多少次幂怎么办？比如10的5次幂？</p>
<p>  ummmm，我想了想，把5拆成4+1呢？也就是10的4次幂再乘以10，这个方法可以。</p>
<p>  那10的6次幂就可以拆成4+2.</p>
<p>  7次方就可以拆成4+2+1.嗯，不错。</p>
<p>  于是，我写了个代码，如下</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pow</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> m = <span class="number">5</span>;</div><div class="line">      <span class="keyword">int</span> n = <span class="number">134</span>;</div><div class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">      System.out.println(<span class="string">"for循环版，结果为 ： "</span> + Double.toString(pow(m, n)));</div><div class="line">      <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">      System.out.println(<span class="string">"for循环版，总耗时： "</span> + (end - start));</div><div class="line"></div><div class="line"></div><div class="line">      start = System.currentTimeMillis();</div><div class="line">      System.out.println(<span class="string">"叠乘法，结果为 ： "</span> + Double.toString(pow2(m, n)));</div><div class="line">      end = System.currentTimeMillis();</div><div class="line">      System.out.println(<span class="string">"叠乘法，总耗时： "</span> + (end - start));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * m的n次方,for循环版</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> m 底数</div><div class="line">   * <span class="doctag">@param</span> n 幂数</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">      <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</div><div class="line">          n = -n;</div><div class="line">          negative = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 循环乘法</div><div class="line">       */</div><div class="line">      <span class="keyword">double</span> result = <span class="number">1L</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">          result *= m;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (negative) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">1</span> / result;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * m的n次方,折中叠乘法</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> m 底数</div><div class="line">   * <span class="doctag">@param</span> n 幂数</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">      <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</div><div class="line">          n = -n;</div><div class="line">          negative = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"><span class="comment">//        当m是2的时候，直接位移就可以。</span></div><div class="line">      <span class="keyword">if</span> (m == <span class="number">2</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; n;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 叠乘法</div><div class="line">       */</div><div class="line"><span class="comment">//        最后结果。</span></div><div class="line">      <span class="keyword">double</span> result = <span class="number">1L</span>;</div><div class="line"><span class="comment">//        定义一个指针，从右向左按位与。</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</div><div class="line"><span class="comment">//            按位与，如果大于0，说明此位为1,需要m的i次方。</span></div><div class="line">          <span class="keyword">if</span> ((i &amp; n) &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">double</span> resultTemp = <span class="number">1L</span>;</div><div class="line"><span class="comment">//                m的i次方不能写成循环i次的m相乘，而是m叠乘，次数为ln(i)。    例如m的8次方，就是((m*m)*(m*m))*((m*m)*(m*m)),也就是 ((m*m)2)2</span></div><div class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j &lt;&lt;= <span class="number">1</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</div><div class="line">                      resultTemp = m;</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      <span class="keyword">if</span> (greatThanMax(resultTemp, resultTemp)) &#123;</div><div class="line">                          <span class="keyword">return</span> Double.MAX_VALUE;</div><div class="line">                      &#125;</div><div class="line">                          resultTemp *= resultTemp;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (greatThanMax(resultTemp, result)) &#123;</div><div class="line">                  <span class="keyword">return</span> Double.MAX_VALUE;</div><div class="line">              &#125;</div><div class="line">              result *= resultTemp;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (negative) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">1</span> / result;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查两个数相乘是否大于double的最大值。</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> m</div><div class="line">   * <span class="doctag">@param</span> n</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greatThanMax</span><span class="params">(<span class="keyword">double</span> m, <span class="keyword">double</span> n)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> (m &gt; (Double.MAX_VALUE / n));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果为</p>
<blockquote>
<p>for循环版，结果为 ： 4.591774807899563E93<br>    for循环版，总耗时： 1<br>    叠乘法，结果为 ： 4.591774807899562E93<br>    叠乘法，总耗时： 0</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java学习路线]]></title>
      <url>/2017/10/24/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      <content type="html"><![CDATA[<h1 id="本文作为收藏用"><a href="#本文作为收藏用" class="headerlink" title="本文作为收藏用"></a>本文作为收藏用</h1><p>##</p>
<p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/39890405/answer/83676977" target="_blank" rel="external">https://www.zhihu.com/question/39890405/answer/83676977</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<ul>
<li><p>第一个是基础。</p>
<blockquote>
<p>比如对集合类，并发包，IO/NIO，JVM，内存模型，泛型，异常，反射，等有深入了解，最好是看过源码了解底层的设计。比如一般面试都会问ConcurrentHashMap，CopyOnWrite，线程池，CAS，AQS，虚拟机优化等知识点，因为这些对互联网的企业是绝对重要的。而且一般人这关都过不了，还发闹骚说这些没什么用，为什么要面试。举一例子，在使用线程池时，因为使用了无界队列，在远程服务异常情况下导致内层飙升，怎么去解决？你要是连线程池都不清楚，你怎么去玩？再举一例，由于对ThreadLocal理解出错，使用它做线程安全的控制，导致没能实现真的线程安全。所以作为一个拿两万的JAVA程序员这点基础是要有的。</p>
</blockquote>
</li>
<li><p>第二你需要有全面的互联网技术相关知识。</p>
<blockquote>
<p>从底层说起，你起码得深入了解mysql，redis，mongodb，nginx，tomcat，rpc，jms等方面的知识。你要问需要了解到什么程度，我可以给你说个大慨。首先对于MySQL，你要知道常见的参数设置，存储引擎怎么去选择，还需要了解常见的索引引擎，知道怎么去选择。知道怎么去设计表，怎么优化sql，怎么根据执行计划去调优。高级的你需要去做分库分表的设计和优化，一般互联网企业的数据库都是读写分离，还会垂直与水平拆分，所以这个也有经验的成分在里面。然后redis，mongodb都是需要了解原理，需要会调整参数的，而nginx和tomcat几乎都是JAVA互联网方面必配，其实很阿里的技术栈选择有点关系。至于rpc相关的就多的去，必须各种网络协议，序列化技术，SOA等等，你要有一个深入的理解。现在应用比较广的rpc框架，在国内就是dubbo了，可以自行搜索。至于jms相关的起码得了解原理吧，一般情况下不是专门开发中间件系统和支撑系统的不需要了解太多细节，国内企业常用的主要是activeMQ和kafka。你能对我说的都研究的比较深入，阿里p7都不是太大问题的，当然这个还需要看你的架构能力方面的面试表现了。</p>
</blockquote>
</li>
<li><p>第三就是编程能力</p>
<blockquote>
<p>编程思想，算法能力，架构能力。首先2W程序员对算法的要求我觉得还是比较低，再高级也最多红黑树吧，但是排序和查询的基本算法得会。编程思想是必须的，问你个AOP和IOC你起码的清清楚楚，设计模式不说每种都用过，但也能了解个几种吧。编程能力这个我觉得不好去评价，但是拿一个2000W用户根据姓名年龄排序这种题目也能信手拈来。最后就是架构能力，这种不是说要你设计个多牛逼多高并发的系统，起码让你做一个秒杀系统，防重请求的设计能快速搞定而没有坑吧。</p>
</blockquote>
</li>
</ul>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><a href="https://www.zhihu.com/question/39890405/answer/83676977" target="_blank" rel="external">在北京做Java开发如何月薪达到两万，需要技术水平达到什么程度？</a><br><a href="https://www.zhihu.com/question/40801731/answer/91814769" target="_blank" rel="external">零基础应该选择学习 java、php、前端 还是 python？</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库架构设计（转发）]]></title>
      <url>/2017/10/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><a href="http://gitbook.cn/books/59be67b577cac00b9c2362fa/index.html" target="_blank" rel="external">链接地址</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库跨库分页实践（转发）]]></title>
      <url>/2017/10/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%A8%E5%BA%93%E5%88%86%E9%A1%B5%E5%AE%9E%E8%B7%B5%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><a href="http://gitbook.cn/books/58a98f512bd83c246b6b8866/index.html" target="_blank" rel="external">转载链接</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[基本类型和包装类型差别]]></title>
      <url>/2017/10/03/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%B7%AE%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="基本类型以及包装类型"><a href="#基本类型以及包装类型" class="headerlink" title="基本类型以及包装类型"></a>基本类型以及包装类型</h2><p>   java中定义了基本类型： </p>
<pre><code>* 整形： byte、short、int、long
* 浮点型：float、double
* 逻辑型： boolean
* 字符型： char
</code></pre><p>   以及对应的包装类型：</p>
<pre><code>* 整形： Byte、Short、Integer、Long
* 浮点型： Float、Double
* 逻辑型： Boolean
* 字符型： Char 
</code></pre><h2 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h2><p>   java为满足程序员基本类型和包装类型混合使用，按需自动装箱拆箱。<br>   自动装箱拆箱使基本类型和包装类型之间的区别逐渐模糊，但是语义上有些许差别，性能上也有明显差别。</p>
<h2 id="基本类型和包装类型差别"><a href="#基本类型和包装类型差别" class="headerlink" title="基本类型和包装类型差别"></a>基本类型和包装类型差别</h2><ul>
<li>基本类型有默认值，例如int值默认为0 ，而Integer没有默认引用，默认为null。<br> 所以在写数据库实体类或者网络请求接收字段的时候要使用包装类型，防止接受参数为null的情况。</li>
<li><p>包装类的频繁更改并不是在原来的基础上更改，而是产生新的对象，所以包装类的频繁更改性能很差.</p>
<blockquote>
<p>使用Long情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">        Long sum = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        System.out.println(sum);</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"using Long total time = "</span> + (end - now));</div></pre></td></tr></table></figure>
</blockquote>
<p>耗费时间为</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2305843005992468481</span></div><div class="line">all time = <span class="number">8832</span></div></pre></td></tr></table></figure>
<blockquote>
<p>使用long情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testlongAutoBoxing</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">         <span class="keyword">long</span> sum = <span class="number">0L</span>;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">             sum += i;</div><div class="line">         &#125;</div><div class="line">         System.out.println(<span class="string">"using long ,sum ="</span> + sum);</div><div class="line">         <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">         System.out.println(<span class="string">"using long total time = "</span> + (end - now));</div><div class="line">     &#125;</div><div class="line">``` </div><div class="line">总耗费时间为</div><div class="line">```java</div><div class="line"> <span class="number">2305843005992468481</span></div><div class="line"> all time = <span class="number">787</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>   在使用Long的时间比long增加10倍，原因是Long的操作过程中会构造大概2^31个实例。</p>
]]></content>
      
        
        <tags>
            
            <tag> EffectJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java单例的七种写法]]></title>
      <url>/2017/09/27/java%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%86%99%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h1><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;   </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">           instance = <span class="keyword">new</span> Singleton();  </div><div class="line">       &#125;  </div><div class="line">     <span class="keyword">return</span> instance;  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">      instance = <span class="keyword">new</span> Singleton();  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> instance;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h1>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line"> <span class="keyword">return</span> instance;  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="饿汉变种"><a href="#饿汉变种" class="headerlink" title="饿汉变种"></a>饿汉变种</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </div><div class="line">  <span class="keyword">static</span> &#123;  </div><div class="line">  instance = <span class="keyword">new</span> Singleton();  </div><div class="line">  &#125;  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </div><div class="line">  &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">      &#125;  </div><div class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">          <span class="keyword">return</span> SingletonHolder.INSTANCE;  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </div><div class="line">     INSTANCE;  </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">     &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </div><div class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;   </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="keyword">synchronized</span> (Singleton.class) &#123;  </div><div class="line">          <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">              singleton = <span class="keyword">new</span> Singleton();  </div><div class="line">          &#125;  </div><div class="line">         &#125;  </div><div class="line">     &#125;  </div><div class="line">     <span class="keyword">return</span> singleton;  </div><div class="line">     &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java线程详解]]></title>
      <url>/2017/09/27/java%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li>新建状态(New) : <blockquote>
<p>线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p>
</blockquote>
</li>
<li>就绪状态(Runnable): <blockquote>
<p>也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</p>
</blockquote>
</li>
<li>运行状态(Running) : <blockquote>
<p>线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p>
</blockquote>
</li>
<li><p>阻塞状态(Blocked) : </p>
<blockquote>
<p>阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<ul>
<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
<li>死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。</li>
</ul>
</blockquote>
</li>
<li><p>Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。</p>
</li>
<li>Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。</li>
<li>synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。</li>
</ul>
<h2 id="实现多线程的两种方式：Thread和Runnable"><a href="#实现多线程的两种方式：Thread和Runnable" class="headerlink" title="实现多线程的两种方式：Thread和Runnable"></a>实现多线程的两种方式：Thread和Runnable</h2><ul>
<li><p>Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下：<br>public interface Runnable {<br> public abstract void run();<br>}<br>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。<br>Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：<br>public class Thread implements Runnable {}<br>Thread的作用，实现多线程。</p>
<h3 id="Thread和Runnable的异同点："><a href="#Thread和Runnable的异同点：" class="headerlink" title="Thread和Runnable的异同点："></a>Thread和Runnable的异同点：</h3></li>
<li>Thread 和 Runnable 的相同点：<blockquote>
<p>都是“多线程的实现方式”。</p>
</blockquote>
</li>
<li>Thread 和 Runnable 的不同点：<blockquote>
<p>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。<br>此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。<br>通常，建议通过“Runnable”实现多线程！</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java并发锁]]></title>
      <url>/2017/09/27/java%E5%B9%B6%E5%8F%91%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul>
<li>锁<br>   -[ ] 公平锁<br>   -[ ] 非公平锁<ul>
<li>隐式锁Synchronized</li>
<li>显式锁Lock<ul>
<li>ReentrantLock</li>
<li>ReadWriteLock</li>
<li>ReentrantReadWriteLock</li>
<li>StampedLock </li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>无锁<ul>
<li>atomic</li>
<li>concurrent</li>
<li>blocking</li>
<li>threadLocal</li>
<li>volatile</li>
<li>CAS</li>
</ul>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><p>Synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">			<span class="keyword">return</span> ++count;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">		lock.lock();</div><div class="line">		<span class="keyword">int</span> newCount = ++count;</div><div class="line">		lock.unlock();</div><div class="line">		<span class="keyword">return</span> newCount;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不可重入自旋锁的简单实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">		<span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">		<span class="keyword">while</span>(isLocked)&#123;</div><div class="line">			wait();</div><div class="line">		&#125;</div><div class="line">		isLocked = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">		isLocked = <span class="keyword">false</span>;</div><div class="line">		notify();</div><div class="line">	&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="threadLocal"><a href="#threadLocal" class="headerlink" title="threadLocal"></a>threadLocal</h2><p>   如果想知道为什么使用ThreadLocal，就得先了解局部变量和全局变量对线程安全的影响。<br>   局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。<br>   当多个线程引用同一个对象时，因为对象引用是放在栈上的，但是对象实例存储在堆中，所以不是线程安全的。</p>
<p>   ThreadLocal就是拷贝一份到线程缓存中，Thread正是操作这个对象，就不会出现安全问题。</p>
<ul>
<li><p>InheritableThreadLocal</p>
<p>InheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。</p>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[深入分析Synchronized]]></title>
      <url>/2017/09/27/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized/</url>
      <content type="html"><![CDATA[<h1 id="Java同步关键字（synchronzied）"><a href="#Java同步关键字（synchronzied）" class="headerlink" title="Java同步关键字（synchronzied）"></a>Java同步关键字（synchronzied）</h1><blockquote>
<p>所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>实例方法同步<br>作用在实例上 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.count += value;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>静态方法同步</p>
<blockquote>
<p>作用在对象上</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.count += value;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>实例方法中同步块</p>
<blockquote>
<p>作用在this这个实例上</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">       <span class="keyword">this</span>.count += value;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>静态方法中同步块</p>
<blockquote>
<p>作用在MyClass这个class上</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</div><div class="line">       log.writeln(msg1);</div><div class="line">       log.writeln(msg2);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</div><div class="line">       <span class="keyword">synchronized</span>(MyClass.class)&#123;</div><div class="line">          log.writeln(msg1);</div><div class="line">          log.writeln(msg2);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>[参考]{<a href="http://ifeve.com/synchronized-blocks/}" target="_blank" rel="external">http://ifeve.com/synchronized-blocks/}</a></p>
<p>[参考2]{<a href="http://cmsblogs.com/?hmsr=toutiao.io&amp;p=2071&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io}" target="_blank" rel="external">http://cmsblogs.com/?hmsr=toutiao.io&amp;p=2071&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io}</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[负载均衡]]></title>
      <url>/2017/09/26/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      <content type="html"><![CDATA[<h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>   负载均衡（Load Balance）是分布式系统架构设计中必须考虑的因素之一，它通常是指，将请求/数据【均匀】分摊到多个操作单元上执行，负载均衡的关键在于【均匀】。</p>
<p>   常见互联网分布式架构如上，分为客户端层、反向代理nginx层、站点层、服务层、数据层。可以看到，每一个下游都有多个上游调用，只需要做到，每一个上游都均匀访问每一个下游，就能实现“将请求/数据【均匀】分摊到多个操作单元上执行”。</p>
<ul>
<li>“客户端层-&gt;反向代理层”的负载均衡<br>【客户端层】到【反向代理层】的负载均衡，是通过“DNS轮询”实现的：DNS-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问DNS-server，会轮询返回这些ip，保证每个ip的解析概率是相同的。这些ip就是nginx的外网ip，以做到每台nginx的请求分配也是均衡的。</li>
<li>“反向代理层-&gt;站点层”的负载均衡<br>  【反向代理层】到【站点层】的负载均衡，是通过“nginx”实现的。通过修改nginx.conf，可以实现多种负载均衡策略：<ul>
<li>请求轮询：和DNS轮询类似，请求依次路由到各个web-server</li>
<li>最少连接路由：哪个web-server的连接少，路由到哪个web-server</li>
<li>ip哈希：按照访问用户的ip哈希值来路由web-server，只要用户的ip分布是均匀的，请求理论上也是均匀的，ip哈希均衡方法可以做到，同一个用户的请求固定落到同一台web-server上，此策略适合有状态服务，例如session.</li>
</ul>
</li>
<li>“站点层-&gt;服务层”的负载均衡<br>   【站点层】到【服务层】的负载均衡，是通过“服务连接池”实现的。<br>   上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</li>
<li>“数据层”的负载均衡<br> 在数据量很大的情况下，由于数据层（db，cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<ul>
<li>数据的均衡是指：水平切分后的每个服务（db，cache），数据量是差不多的。</li>
<li>请求的均衡是指：水平切分后的每个服务（db，cache），请求量是差不多的。<br>业内常见的水平切分方式有这么几种：<ul>
<li>按照range水平切分        <ul>
<li>好处<ul>
<li>规则简单，service只需判断一下uid范围就能路由到对应的存储服务</li>
<li>数据均衡性较好</li>
<li>比较容易扩展，可以随时加一个uid[2kw,3kw]的数据服务</li>
</ul>
</li>
<li>不足是：<ul>
<li>请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大range的服务请求压力会更大</li>
</ul>
</li>
</ul>
</li>
<li>按照id哈希水平切分<ul>
<li>好处：<ul>
<li>规则简单，service只需对uid进行hash能路由到对应的存储服务</li>
<li>数据均衡性较好</li>
<li>请求均匀性较好</li>
</ul>
</li>
<li>不足：<ul>
<li>不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[代理]]></title>
      <url>/2017/09/26/%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><pre><code>&gt;服务器ip地址不变，用户ip地址变。例如用户(1.1.1.1)使用正向代理(2.2.2.2)访问服务器(3.3.3.3),那么服务器收到的消息来自2.2.2.2.服务器不知道用户真正的地址。
</code></pre><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><pre><code>&gt; 反之，用户不知道服务器的地址。
</code></pre><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><pre><code>对用户屏蔽高可用、屏蔽web-server扩展、内网等一些细节。
由于web-server有多台，需要进行负载均衡。
</code></pre><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="[负载均衡]{}"></a>[负载均衡]{}</h1><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li>nginx/apache</li>
<li>F5</li>
<li>lvs</li>
</ul>
<h2 id="什么是四层（转发-交换），什么是七层（转发-交换）？"><a href="#什么是四层（转发-交换），什么是七层（转发-交换）？" class="headerlink" title="什么是四层（转发/交换），什么是七层（转发/交换）？"></a>什么是四层（转发/交换），什么是七层（转发/交换）？</h2><p>   <img src="img/网络协议7层与5层协议.png" alt="这个是来源于OSI七层模型"><br>   由图可见，4层指传输层，7层指应用层<br>   更具体的，对应到nginx反向代理hash：</p>
<ul>
<li>四层：根据用户ip+port来做hash</li>
<li>七层：根据http协议中的某些属性来做hash</li>
</ul>
<h2 id="为什么中间少了几层？"><a href="#为什么中间少了几层？" class="headerlink" title="为什么中间少了几层？"></a>为什么中间少了几层？</h2><pre><code>OSI应用层、表示层、会话层合并到TCP/IP的应用层啦。
</code></pre><h2 id="上面有四层，七层，那有没有二层，三层呢？"><a href="#上面有四层，七层，那有没有二层，三层呢？" class="headerlink" title="上面有四层，七层，那有没有二层，三层呢？"></a>上面有四层，七层，那有没有二层，三层呢？</h2><ul>
<li>二层：根据数据链路层MAC地址完成数据交换</li>
<li>三层：根据网络层IP地址完成数据交换   </li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[炸了那个Jvm]]></title>
      <url>/2017/09/25/%E7%82%B8%E4%BA%86%E9%82%A3%E4%B8%AAJvm/</url>
      <content type="html"><![CDATA[<p><a href="http://zhuanlan.51cto.com/art/201709/550451.htm" target="_blank" rel="external">http://zhuanlan.51cto.com/art/201709/550451.htm</a></p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>   <img src="img/JVM内存模型.jpg" alt=""></p>
<p>   打印出来的信息：</p>
<pre><code>PSYoungGen      total 3072K, used 128K 
    eden space 2560K, 5% used  
    survivor  space 
        from space 512K, 0% used  
         to   space 512K, 0% used  

ParOldGen       total 6656K, used 408K 
    object space 6656K, 6% used   

PSPermGen       total 4096K, used 3039K    
    object space 4096K, 74% used  
</code></pre><h2 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h2><ul>
<li>年轻代：<br>  存放对象的特点： 生命周期短，多为临时变量。<blockquote>
<p>新实例化的对象都会在eden中new出来，经过手动System.gc()（本质上也是调用Runtime的gc）、Runtime.getRuntime().gc()（本地方法）或者一段时间后系统自动触发gc，年轻代使用 <em>复制清除</em>算法 ，从Root对象开始标记为存活，存活的对象引用的对象也会标记为存活，扫描整个eden区后，将存活的对象存放到其中一个survivor区，清除eden区和另外一个eden区。下次再产生新的对象仍然是放到eden区内，再gc时将eden区和有对象存储的survivor存活的对象复制到另外一个survivor区内，清除这两个区，反复如此，清除一定次数后（之前看过介绍15次，不太确定）将仍然存活的放到年老代。</p>
</blockquote>
</li>
<li>年老代<br>  存放对象特点： 生命周期长。<blockquote>
<p>年老代使用<em>标记整理</em>算法，还是从Root对象开始搜索，标记所有存活的对象，把所有存活的对象复制到一个区域内，再清除其他区域。</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="栈内存溢出-java-lang-StackOverflowError"><a href="#栈内存溢出-java-lang-StackOverflowError" class="headerlink" title="栈内存溢出(java.lang.StackOverflowError)"></a>栈内存溢出(java.lang.StackOverflowError)</h3><pre><code>&gt; -Xmx10m
  -XX:MaxPermSize=5m
  -XX:MaxDirectMemorySize=5m
  -XX:+PrintGCDetails
</code></pre><h3 id="永久代溢出-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded"><a href="#永久代溢出-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded" class="headerlink" title="永久代溢出(java.lang.OutOfMemoryError: GC overhead limit exceeded)"></a>永久代溢出(java.lang.OutOfMemoryError: GC overhead limit exceeded)</h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Collections类全解析]]></title>
      <url>/2017/09/24/Collections%E7%B1%BB%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql内连接、左外连接、右外连接、全连接]]></title>
      <url>/2017/09/23/Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%85%A8%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h2 id="指定方式"><a href="#指定方式" class="headerlink" title="指定方式"></a>指定方式</h2><blockquote>
<p>连接条件可以在FROM或WHERE语句中指定。</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>内连接</p>
<blockquote>
<p>典型的连接运算，使用=或者&lt;&gt;之类的比较运算。包括相等连接和自然连接。<br>内连接使用比较运算符根据每个表共有的值匹配两个表中的行。</p>
</blockquote>
</li>
<li><p>外连接</p>
<ul>
<li><p>左外连接</p>
<blockquote>
<p>left join 结果集包括左表中的所有行，如果左表的某行在右表中没有匹配行，结果集中显示为空。</p>
</blockquote>
</li>
<li><p>右外连接</p>
<blockquote>
<p>与左外连接相反。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>全连接</p>
<blockquote>
<p>返回左表和右表中所有的行。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql索引]]></title>
      <url>/2017/09/23/Mysql%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>由用户创建的，能够被修改和删除的，实际存储在数据库中的物理存在。它是某一表中一列或者若干列值得集合和相应的指向表中物理标志这些值的数据页的逻辑指针清单</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>通过创建唯一索引，可以保证数据库中每一行数据的唯一性。</li>
<li>大大加快数据的检索速度。</li>
<li>加速表与表之间的联系。</li>
<li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统性能。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>创建和维护索引需要耗费时间，时间随数据量增加而增加。</li>
<li>索引占据物理空间，如果建立聚簇索引，占用空间更大。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>聚集索引，表中数据按照索引的顺序来存储。叶子节点存储了真实的数据行，没有另外单独的数据页。</li>
<li>非聚集索引，表数据存储顺序与索引顺序无关，叶节点包含索引字段值及指向数据页数据行的逻辑指针。</li>
<li>一张表上只能创建一个聚集索引，因为真实数据的物理顺序只能是一种。如果一张表没有聚集索引，它被称为“堆集”，没有特定的顺序，新加的元行被添加到末尾。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> [object Object] </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList原理]]></title>
      <url>/2017/09/23/ArrayList%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>  存储数据是通过数组： transient Objectp[] elementData<br>  size字段： 存储整个数组的大小，</p>
<pre><code>&gt; 注意的是： size是每次add和remove都会自增和自减的，所以增加null也会size+1.
</code></pre><ul>
<li>是否允许空：<br>允许</li>
<li>是否允许重复数据：<br>允许</li>
<li>是否有序：<br>是</li>
<li>是否线程安全：<br>不是</li>
</ul>
<h2 id="默认大小-10"><a href="#默认大小-10" class="headerlink" title="默认大小 : 10"></a>默认大小 : 10</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">( <span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">  modCount++;</div><div class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">  <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</div><div class="line">      Object oldData[] = elementData;</div><div class="line">      <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</div><div class="line">          <span class="keyword">if</span> (newCapacity &lt; minCapacity)</div><div class="line">      newCapacity = minCapacity;</div><div class="line">             <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">             elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">           &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><ul>
<li>根据下标删除。</li>
<li><p>根据元素删除。</p>
<blockquote>
<p>删除跟元素匹配的 <em>第一个</em> 元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line"></div><div class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line"></div><div class="line">         numMoved);</div><div class="line"></div><div class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div></pre></td></tr></table></figure>
<ul>
<li>1、把指定元素后面位置的所有元素，利用System.arraycopy方法整体向前移动一个位置</li>
<li>2、最后一个位置的元素指定为null，这样让gc可以去回收它<blockquote>
<p>因为删除的时候，需要将后面所有元素向前移动一个位置，所以删除的时候，很消耗性能。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><ul>
<li>add(T t)</li>
<li>add(int position,T t)<blockquote>
<p>插入时候会将所有后面的元素向后移动一个位置，很消耗性能。</p>
</blockquote>
</li>
</ul>
<h2 id="ArrayList的优缺点"><a href="#ArrayList的优缺点" class="headerlink" title="ArrayList的优缺点"></a>ArrayList的优缺点</h2><ul>
<li>底层以数组方式存储，是一种随机访问方式，并且实现了RandomAccess接口，因此查找十分快速。</li>
<li><p>添加很方便，往数组的最后添加一个就行了。</p>
</li>
<li><p>删除和添加的时候涉及到移动后面所有数据，性能消耗比较大。    </p>
</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote>
<p>不是线程安全的，所有方法都没有Synchronized修饰，在并发情况下会出现安全问题。可以使用Collections.synchronizedList方式</p>
</blockquote>
<h2 id="为什么ArrayList的elementData是用transient修饰的？"><a href="#为什么ArrayList的elementData是用transient修饰的？" class="headerlink" title="为什么ArrayList的elementData是用transient修饰的？"></a>为什么ArrayList的elementData是用transient修饰的？</h2><blockquote>
<p>private transient Object[] elementData;</p>
<p>ArrayList 实现了Serializable接口，所以是可以序列化的。但是elementData不一定是满的，没必要全部序列化。所以ArrayList重写了writeObject方法实现，增快了序列化的速度，见笑了序列化后的大小：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line"><span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line"><span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">s.defaultWriteObject();</div><div class="line">        <span class="comment">// Write out array length</span></div><div class="line">       s.writeInt(elementData.length);</div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</div><div class="line">           s.writeObject(elementData[i]);</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java8新增功能]]></title>
      <url>/2017/09/18/java8%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="接口中default关键字修饰方法可以增加默认实现。"><a href="#接口中default关键字修饰方法可以增加默认实现。" class="headerlink" title="接口中default关键字修饰方法可以增加默认实现。"></a>接口中default关键字修饰方法可以增加默认实现。</h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Math.sqrt(a);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names,(a,b)-&gt;b.compareTo(a));</div></pre></td></tr></table></figure>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Coverter</span>&lt;<span class="title">F</span>,<span class="title">T</span>&gt;</span>&#123;</div><div class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Convert&lt;String,Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div></pre></td></tr></table></figure>
<h1 id="方法和构造函数引用"><a href="#方法和构造函数引用" class="headerlink" title="方法和构造函数引用"></a>方法和构造函数引用</h1><ul>
<li><p>静态方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Convert&lt;String,Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>通过:: 关键字获取方法或者构造函数的引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span>&#123;</div><div class="line">  <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Something something = <span class="keyword">new</span> Something();</div><div class="line">Converter&lt;String,String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"java"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>引用构造函数<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  String firstName；</div><div class="line">  String lastName；</div><div class="line">  Person()&#123;&#125;;</div><div class="line">  Person(String firstName,String lastName)&#123;</div><div class="line">    <span class="keyword">this</span>.firstName=firstName;</div><div class="line">    <span class="keyword">this</span>.lastName=lastName;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//新建工厂类</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt;</span>&#123;</div><div class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName,String lastName)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过构造函数引用将所有东西拼到一起，通过手动实现。</span></div><div class="line"></div><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"earyant"</span>,<span class="string">"Lee"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="类库示例"><a href="#类库示例" class="headerlink" title="类库示例"></a>类库示例</h1><h2 id="Predicates-断言"><a href="#Predicates-断言" class="headerlink" title="Predicates(断言)"></a>Predicates(断言)</h2><blockquote>
<p>是一个布尔类型的函数，该函数只有一个输入函数，它实现了多种默认方法，用于处理复杂的逻辑动词。(and ,or,negate(否定))</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s)-&gt;s.length()&gt;<span class="number">0</span>;</div><div class="line">predicate.test(<span class="string">"earyant"</span>)  <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"earyant"</span>); <span class="comment">//false  </span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><blockquote>
<p>接收一个参数，并返回单一的结果，默认方法可以将多个函数穿在一起(compose，andThen)：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Function&lt;String,Integer&gt; toInteger = Integer:valueOf;</div><div class="line">Function&lt;String,String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line">backToString.apply(<span class="string">"123"</span>);</div></pre></td></tr></table></figure>
<h2 id="Suppliers"><a href="#Suppliers" class="headerlink" title="Suppliers"></a>Suppliers</h2><blockquote>
<p>Supplier 接口产生一个给定类型的结果，与Function不同的是，Supplier没有输入参数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person:<span class="keyword">new</span>;</div><div class="line">personSupplier.get();</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring中的事务管理]]></title>
      <url>/2017/09/17/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性<h2 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h2></li>
<li>声明式事务</li>
<li>编程式事务</li>
</ul>
<h2 id="数据错误类型"><a href="#数据错误类型" class="headerlink" title="数据错误类型"></a>数据错误类型</h2><ul>
<li><p>脏读(dirty read)</p>
<blockquote>
<p>当前有两个事务A和B，当A事务对数据进行更改，但是还没提交（会有缓存），此时被事务B读取，然后事务A因其他原因导致失败数据回滚，此时的事务A的操作都是失败的，对数据的操作也是失败的，但是B事务已经读取了A没提交的数据，导致B读到了错误的数据。</p>
</blockquote>
</li>
<li><p>不可重复读(no-repeatable-read)</p>
<blockquote>
<p>当前有两个事务A和B，A事务将会对数据进行两次操作，当A事务操作一次成功后，B事务此时对数据操作更改了值并提交，随后A事务再进行读取数据，发现数据已经被更改，造成A事务的数据混乱。</p>
</blockquote>
</li>
<li><p>幻读(phantom read)</p>
<blockquote>
<p>与不可重复读同样都是多次读数据不一致的问题，但是no-repeatable-read强调的是本身需要的数据集改变了， phantom read强调多次查询得出的条件数据集改变了。</p>
</blockquote>
</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li>ISOLATION_DEFAULT 默认级别</li>
<li>ISOLATION_READ_UNCOMMIT   事务最低级别，允许其他事务看到此事务中未提交的数据。   <strong>这种级别会导致脏读、幻读、不可重复读</strong></li>
<li>ISOLATION_READ_COMMIT   保证数据提交后才能被另外一个事务看到。  <strong>这种级别可以防止脏读，但是不能防止不可重复读和幻读</strong></li>
<li>ISOLATION_REPEATABLE_READ       <strong>这种级别可以防止脏读、不可重复读，但是不能防止幻读</strong></li>
<li>ISOLATION_SERALIZABLE     <strong>最强级别，可以防止脏读、不可重复读、幻读</strong></li>
</ul>
<h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ul>
<li><p>PROPAGATION_REQUIRED 如果存在一个事务，就是用这个事务，如果没有事务，就开启一个新的事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</div><div class="line">    ...</div><div class="line">    methodB();</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>PROPAGATION_SUPPORTS 如果存在一个事务，就用这个事务，如果没有事务，就非事务执行，但是对于事务同步管理器，PROPAGATION_SUPPORTS和不使用事务有少许区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</div><div class="line">    ...</div><div class="line">    methodB();</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//事务属性 PROPAGATION_SUPPORTS</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当通过methodA调用methodB时，methodB就是用methodA的事务，如果单独调用methodB的时候，methodB就非事务执行。</p>
</li>
<li>PROPAGATION_MANDATORY 如果存在一个事务，就是用当前事务，如果不存在事务，就抛出一个异常。</li>
<li><p>PROPAGATION_REQUIRED_NEW 开启一个新的事务，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</div><div class="line">  doSomeThingA();</div><div class="line">  methodB();</div><div class="line">  doSomeThingB();</div><div class="line">&#125;</div><div class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRES_NEW</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">TransactionManager tm = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">  <span class="comment">//获得一个JTA事务管理器</span></div><div class="line">  tm = getTransactionManager();</div><div class="line">  tm.begin();<span class="comment">//开启一个新的事务</span></div><div class="line">  Transaction ts1 = tm.getTransaction();</div><div class="line">  doSomeThing();</div><div class="line">  tm.suspend();<span class="comment">//挂起当前事务</span></div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    tm.begin();<span class="comment">//重新开启第二个事务</span></div><div class="line">    Transaction ts2 = tm.getTransaction();</div><div class="line">    methodB();</div><div class="line">    ts2.commit();<span class="comment">//提交第二个事务</span></div><div class="line">  &#125;</div><div class="line">  Catch(RunTimeException ex)&#123;</div><div class="line">    ts2.rollback();<span class="comment">//回滚第二个事务</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">finally</span>&#123;</div><div class="line">   <span class="comment">//释放资源</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//methodB执行完后，复恢第一个事务</span></div><div class="line">  tm.resume(ts1);</div><div class="line">  doSomeThingB();</div><div class="line">  ts1.commit();<span class="comment">//提交第一个事务</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(RunTimeException ex)&#123;</div><div class="line">  ts1.rollback();<span class="comment">//回滚第一个事务</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line"><span class="comment">//释放资源</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了methodB之外的其它代码导致的结果却被回滚了。使用PROPAGATION_REQUIRES_NEW,需要使用JtaTransactionManager作为事务管理器。</p>
</blockquote>
</li>
</ul>
<ul>
<li>PROPAGATION_NOT_SUPPORTED 总是非事务执行，并挂起任何事务，也需要JTATransctionManager作为事务管理器</li>
<li>PROPAGATION_NEVER  总是非事务执行，如果存在一个事务，则抛出异常。</li>
<li><p>PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而nestedTransactionAllowed属性值默认为false;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></div><div class="line">methodA()&#123;</div><div class="line">doSomeThingA();</div><div class="line">methodB();</div><div class="line">doSomeThingB();</div><div class="line">&#125;</div><div class="line"><span class="comment">//事务属性 PROPAGATION_NESTED</span></div><div class="line">methodB()&#123;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">  Connection con = <span class="keyword">null</span>;</div><div class="line">Savepoint savepoint = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"> con = getConnection();</div><div class="line"> con.setAutoCommit(<span class="keyword">false</span>);</div><div class="line"> doSomeThingA();</div><div class="line"> savepoint = con2.setSavepoint();</div><div class="line"> <span class="keyword">try</span>&#123;</div><div class="line">     methodB();</div><div class="line"> &#125;<span class="keyword">catch</span>(RuntimeException ex)&#123;</div><div class="line">    con.rollback(savepoint);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">finally</span>&#123;</div><div class="line">   <span class="comment">//释放资源</span></div><div class="line">&#125;</div><div class="line">  doSomeThingB();</div><div class="line">  con.commit();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(RuntimeException ex)&#123;</div><div class="line">  con.rollback();</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line"> <span class="comment">//释放资源</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。<br>  使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。<br>  PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。<br>  另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。<br>  由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back.<br>  PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ结合Aop实现高并发Log记录]]></title>
      <url>/2017/09/17/RabbitMQ%E7%BB%93%E5%90%88Aop%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91Log%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<ul>
<li>[] <a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1505634383&amp;ver=397&amp;signature=4eGGO7W4eNN4mhNGRac0hSUTD4tyNwjT0H7tPfYWtEtLPR-TQ0VZAn2dItajttVRP-XgFlJCnrNjkPB95EHmxv-H2k1*uzuHen-VibsJg-464Y8MjAZPKAeuZPBjzBhn&amp;new=1" target="_blank" rel="external">参考</a></li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[aop原理及实现]]></title>
      <url>/2017/09/17/aop%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="静态代理、动态代理"><a href="#静态代理、动态代理" class="headerlink" title="静态代理、动态代理"></a>静态代理、动态代理</h2><p>1、AspectJ 使用静态代理，生成class文件时，会侵入到代码中。<br>2、Spring AOP 使用动态代理，不会侵入代码，而是在内存中临时为代码生成一个AOP对象，这个AOP对象包含目标对象的全部方法，并且在特定切点进行增强处理，并且调原对象的方法。</p>
<ul>
<li>Jvm动态代理： 通过反射接收代理的类，并要求被代理的类必须实现一个接口。JVM代理的核心是InvocationHandler接口和proxy类。</li>
<li>CGLib(Code Generation Library)： 如果目标没有实现接口，那么Spring会使用CGLib动态代理目标类。它是一个代码生成的类库，可以在运行时动态生成某个类的子类。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意： CGLib是通过继承方式实现的，如果某个类被标记为final，是不能通过CGLib实现动态代理的。</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="示例-使用了CGLib-："><a href="#示例-使用了CGLib-：" class="headerlink" title="示例(使用了CGLib)："></a>示例(使用了CGLib)：</h2><p>  定义Person类，其中sayHello方法是切点，切点被Timer注解修饰。<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="meta">@Timer</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"sayHello"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  配置切点：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdviceTest</span></span>&#123;</div><div class="line">  <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.earyant.aop.Timer)"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"before"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  在Mail类中调用。<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> Person person;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    person.sayHello();</div><div class="line">    System.out.println(person.getClass().getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  输出结果：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">before</div><div class="line">sayHello</div><div class="line">com.earyant.aop.Person$$EnhancerBySpringCGLIB$$56b89168</div></pre></td></tr></table></figure></p>
<h2 id="示例-JVM代理"><a href="#示例-JVM代理" class="headerlink" title="示例(JVM代理)"></a>示例(JVM代理)</h2><p>  定义一个接口：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chinese</span></span>&#123;</div><div class="line">  sayHello();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  令Person类继承自Chinese类。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Chinese</span></span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="meta">@Timer</span></div><div class="line">  sayHello()&#123;</div><div class="line">    System.out.println(<span class="string">"sayHello"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  此代码运行的结果是：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">before</div><div class="line">sayHello</div><div class="line">com.sun.proxy.$Proxy53</div></pre></td></tr></table></figure></p>
<p>  证明使用了JVM代理。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM调优]]></title>
      <url>/2017/09/15/JVM%E8%B0%83%E4%BC%98/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[从敲下www.baidu.com到浏览器显示页面，都发生了什么？]]></title>
      <url>/2017/09/12/%E4%BB%8E%E6%95%B2%E4%B8%8Bwww-baidu-com%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMvc工作流程]]></title>
      <url>/2017/09/12/SpringMvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="SpringMVC核心流程-主要在doDispatch方法中"><a href="#SpringMVC核心流程-主要在doDispatch方法中" class="headerlink" title="SpringMVC核心流程,主要在doDispatch方法中"></a>SpringMVC核心流程,主要在doDispatch方法中</h2><ul>
<li>1、用户发送请求，被SpringMvc的DispatcherServlet捕获到</li>
<li>2、DispatcherServlet对获取到的URL进行解析，得到统一定位符URI，然后根据URI调用HandlerMapping获得Handler对象以及跟handler相关的拦截器，最后以HandlerExecutionChain对象形式返回。</li>
<li>3、DispatcherServlet根据返回的Handler选择合适的HandlerAdapter，如果找到了HandlerAdapter,在之前就会执行preHandler方法</li>
<li>4、提取request中的模型数据，填充Handler入参，开始执行Handler<ul>
<li>在填充的过程中，SpringMvc会做一些操作：<ul>
<li>HttpMessageConvert ： 将消息转换成一个对象，将对象转换成指定的响应信息。</li>
<li>数据转换： 比如将String转换成Integer等</li>
<li>数据格式化： 日期格式化等</li>
<li>数据验证： 验证数据的有效性，包括长度、类型等等，验证结果存储到BindingResult或者Error中。</li>
</ul>
</li>
</ul>
</li>
<li>5、Handler执行完成后，像DispatcherServlet返回一个ModelAndView。</li>
<li>6、根据返回的ModelAndView选择一个合适的ViewResolver返回给DispatcherServlet</li>
<li>7、ViewResolveModel和View来渲染视图</li>
<li>8、将渲染结果返回给客户端</li>
</ul>
<h2 id="处理关键"><a href="#处理关键" class="headerlink" title="处理关键"></a>处理关键</h2><ul>
<li>DispatcherServlet的HandlerMapping集合中根据请求的URL匹配每一个handlerMapping对象中的某个handler,匹配成功后将会返回这个handler的处理连接handlerExecutorChain对象，而这个对象中包括多个handlerInterceptor。</li>
<li>HandlerInterceptor中包含三个方法<ul>
<li>preHandler，在Handler执行之前调用。</li>
<li>postHandler，在Handler执行之后调用。</li>
<li>afterComplete，在view渲染完成后，dispatchServlet返回之前调用。</li>
</ul>
</li>
<li>当preHandler返回false时，请求将在执行afterComplete后直接返回，不会执行handler。    </li>
</ul>
<h2 id="首先有几个类需要声明-ModelAndView、HandlerExecutionChain、HandlerMapping、HandlerMethod、HandlerAdapter。"><a href="#首先有几个类需要声明-ModelAndView、HandlerExecutionChain、HandlerMapping、HandlerMethod、HandlerAdapter。" class="headerlink" title="首先有几个类需要声明,ModelAndView、HandlerExecutionChain、HandlerMapping、HandlerMethod、HandlerAdapter。"></a>首先有几个类需要声明,ModelAndView、HandlerExecutionChain、HandlerMapping、HandlerMethod、HandlerAdapter。</h2><ul>
<li>1、HandlerMethod(org.springframework.web.method.HandlerMethod)，这个类为中存放了某个bean对象和该bean对象的某个要处理的Method对象。</li>
<li>2、HandlerMapping,作用为通过request对象，获取对应的HandlerMethod对象。</li>
<li>3、HandlerExecutionChain作用为通过加入Interceptor拦截器包装HandlerMapping返回的HandlerMethod对象。让待处理的方法对象与拦截器称为一个整体,即执行链。</li>
<li>4、ModelAndView,顾名思义。Model即MVC的M，View即MVC的V。其对象存放的正是数据与视图信息。</li>
<li>5、HandlerAdapter:作用为具体处理HandlerMethod,即通过它调用某个方法。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/09/12/README/</url>
      <content type="html"><![CDATA[<h1 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h1>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[取余和取模的区别]]></title>
      <url>/2017/09/10/%E5%8F%96%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList和LinkedList对比]]></title>
      <url>/2017/09/10/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>ArrayList ： 继承自List接口</li>
<li>LinkedList ： 继承自List和Deque接口</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li>ArrayList ：底层用数组进行存储</li>
<li>LinkedList ： 底层用双链表进行存储 </li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>ArrayList ： 访问速度快，插入和删除比较慢 ，需要移动元素</li>
<li>LinkedList ： 访问比较慢，插入和删除比较快 ， 需要链式查询</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java集合框架]]></title>
      <url>/2017/09/10/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h2 id="顶级接口："><a href="#顶级接口：" class="headerlink" title="顶级接口："></a>顶级接口：</h2><ul>
<li>Collection<br>  <img src="img/Collection接口继承关系.jpg" alt=""></li>
<li>Map<br>  <img src="img/Map接口继承关系.jpg" alt=""></li>
</ul>
<h2 id="顶级类："><a href="#顶级类：" class="headerlink" title="顶级类："></a>顶级类：</h2><ul>
<li>Collections</li>
</ul>
<h3 id="接口描述"><a href="#接口描述" class="headerlink" title="接口描述"></a>接口描述</h3><ul>
<li><p>Collection ：  不提供直接子类继承，只提供继承的子接口（List和Set）</p>
<ul>
<li><p>List : 有序的Collection，控制元素的插入位置，和通过索引访问List数据，允许相同的Key。</p>
<ul>
<li>Verctor<ul>
<li>Stack</li>
</ul>
</li>
<li>ArrayList</li>
<li><p>LinkedList( 也继承自 Deque)</p>
</li>
<li><p><a href="https://earyant.github.io/2017/09/10/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/">ArrayList和LinkedList对比</a></p>
</li>
</ul>
</li>
<li><p>Set ： 不保存重复数据</p>
<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>SortedSet<ul>
<li>TreeSet</li>
</ul>
</li>
<li>EnumSet</li>
</ul>
</li>
<li>Queue<ul>
<li>DeQue<ul>
<li>LinkedList</li>
</ul>
</li>
<li>PriorityQueue</li>
</ul>
</li>
</ul>
</li>
<li>Map<ul>
<li>EnumMap</li>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>IdentityMap</li>
<li>HashTable<ul>
<li>Properties</li>
</ul>
</li>
<li>SortedMap<ul>
<li>TreeMap</li>
</ul>
</li>
<li>WeakHashMap</li>
</ul>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java整理]]></title>
      <url>/2017/09/09/java%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="算法和数据结构（性能，场景）："><a href="#算法和数据结构（性能，场景）：" class="headerlink" title="算法和数据结构（性能，场景）："></a>算法和数据结构（性能，场景）：</h2><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><ul>
<li>数组</li>
<li>链表</li>
<li>树<ul>
<li>红黑树</li>
<li>AVL树</li>
<li>Hash树</li>
<li>tire树</li>
<li>b-树</li>
<li>b+树</li>
</ul>
</li>
<li>队列</li>
<li>栈<h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3></li>
<li>查找：<ul>
<li>二分查找，以及变种二分查找。</li>
</ul>
</li>
<li>排序：<ul>
<li>7种排序</li>
<li>时间、空间复杂度（理解并分析）</li>
<li>动态规划、贪心算法</li>
<li>图<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3></li>
</ul>
</li>
<li>OSI7层协议（TCP四层）<ul>
<li>URL到页面的过程</li>
</ul>
</li>
<li>http:<ul>
<li>http/https 1.0、1.1、2.0</li>
<li>get/post 以及幂等性</li>
<li>http相关头协议</li>
</ul>
</li>
<li>网络攻击（CSRF、XSS）</li>
<li>TCP/IP<ul>
<li>三次握手、四次握手</li>
<li>拥塞控制（过程、阙值）</li>
<li>TCP与UDP比较</li>
<li>子网掩码</li>
<li>DDos攻击</li>
</ul>
</li>
<li>BIO、IO、NIO、AIO<ul>
<li>原理</li>
<li>Netty</li>
<li>linux内核的select poll epoll<h3 id="数据库-mysql"><a href="#数据库-mysql" class="headerlink" title="数据库(mysql)"></a>数据库(mysql)</h3></li>
</ul>
</li>
<li>索引<ul>
<li>分类<ul>
<li>全文索引</li>
<li>HASH索引</li>
<li>BTree索引</li>
<li>RTree索引</li>
<li>普通索引</li>
<li>唯一索引</li>
<li>主索引</li>
<li>外键索引</li>
<li>复合索引</li>
</ul>
</li>
</ul>
</li>
<li>优化方式<ul>
<li>失效条件</li>
<li>底层结构</li>
</ul>
</li>
<li>sql语法<ul>
<li>join、union、子查询、having、group by</li>
</ul>
</li>
<li>引擎对比<ul>
<li>InnoDB</li>
<li>MyISAM</li>
</ul>
</li>
<li>[锁]{}<ul>
<li>行锁、表锁、页级锁、意向锁、读锁、写锁、悲观锁、乐观锁、以及枷锁的select sql方式</li>
</ul>
</li>
<li>隔离级别<ul>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
</li>
<li>事务的ACID</li>
<li>B树</li>
<li>B+树</li>
<li>优化<ul>
<li>explain</li>
<li>慢查询</li>
<li>show profile</li>
<li>数据库的范式</li>
<li>分库分表</li>
<li>主从复制</li>
<li>读写分离<h3 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h3></li>
</ul>
</li>
<li>redis</li>
<li>memcached</li>
<li>mongdb</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>进程通信IPC，与线程区别</li>
<li>OS集中策略、进程调度</li>
<li>互斥与死锁</li>
<li>linux相关命令<ul>
<li>cpu命令</li>
<li>内存</li>
<li>部署</li>
<li>vim<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3></li>
</ul>
</li>
<li>面向对象</li>
<li><p><a href="https://earyant.github.io/2017/09/10/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合</a></p>
<ul>
<li>map<ul>
<li><a href="https://earyant.github.io/2017/08/09/HashMap%E5%85%A8%E8%A7%A3%E6%9E%90/">Hashmap</a></li>
<li>EnumMap: 枚举类型座位键值的Map，效率要高于HashMap</li>
<li>HashTable：</li>
<li>ConcurrentHashMap：<ul>
<li>get操作全并发访问，put操作可配置并发操作的哈希表，并发级别可以通过构造参数中的concurrentLevel参数设置(默认级别为16).该参数会在Map内部划分一些分区，在put的时候，只有更新的分区是锁住的。</li>
</ul>
</li>
<li>ConcurrentSkipListMap： 基于跳跃表的ConcurrentNavigableMap实现。本质上这种集合可以当做TreeMap的线程安全版本来使用。</li>
<li>IdentityHashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>WeakHashMap</li>
</ul>
</li>
<li>list<ul>
<li>ArrayList<ul>
<li>内部用一个整形数字或者数组存储了集合的大小。</li>
<li>访问速度稳定；</li>
<li>在尾部添加成本低，在头部添加成本高(线性复杂度)。</li>
</ul>
</li>
<li>LinkedList<ul>
<li>Deque实现，每一个节点都保存着上一个节点和下一个节点的指针。所以数据的存取和更新都具有线性复杂度。<br><a href="https://earyant.github.io/2017/09/10/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/">ArrayList和LinkedList对比</a></li>
</ul>
</li>
<li>Vector</li>
</ul>
</li>
<li><p>set</p>
<ul>
<li>HashSet</li>
<li>EnumSet</li>
<li>BitSet</li>
<li>LinkedHashMap</li>
<li>TreeSet</li>
<li>ConcurrentSkipListSet ： 使用ConcurrentSkipListMap来存储线程安全的Set。</li>
<li>CopyOnWriteArraySet： 使用CopyOnWriteArrayList存储的线程安全的Set</li>
</ul>
</li>
<li><p>Queues/Deques</p>
<ul>
<li>ArrayDeQue ： Deque是基于有首尾指针的数组（环形缓冲区）实现的。和LinkedList不同，这个类没有实现List接口，因此，如果没有收尾元素的话，就不能去除任何元素。比LinkedList好一点，产生的垃圾数量较少。</li>
<li>Stack ：后进先出的队列<br>– 并发 –</li>
<li>ArrayBlockingQueue： 基于书实现的一个有界阻塞对，大小不能重新定义，试图向一个满的队列添加元素的时候，就会受到阻塞，知道另一个方法从队列中取出元素。</li>
<li>ConcurrentLinkedDeque、ConcurrentLinkedQueue：基于链表实现的无解队列，添加元素不阻塞。要求消费者的速度至少要比生产一样快，不然内存就会耗尽，严重依赖于CAS操作。</li>
<li>DelayQueue ： 无界的保存Delayed元素的集合，元素只有在延时已经过期的时候才能被取出。队列的第一个元素延期最小(包含负值，延时已经过期)，要实现一个延期任务的队列的时候使用(不要自己手动实现–使用ScheduledThreadPoolExecutor)</li>
<li>LinkedBlockingDeque/LinkedBlockingQueue： 可选择有界或者无界基于链表的实现。在队列为空或者满的情况下使用ReentrantLock</li>
<li>LinkedTransferQueue: 基于链表的无界队列，除了通常的队列操作，还有一系列的transfer方法，可以让生产者直接给等待的消费者传递信息，这样就不用将元素存储到队列中了，这是一个基于CAS的无锁集合</li>
<li>PriorityBlockingQueue：PriorityQueue的无界的版本。</li>
<li>SynchronousQueue：一个有界队列，其中没有任何内存容量。这就意味着任何插入操作必须等到响应的取出操作才能执行，反之亦反。如果不需要Queue接口的话，通过Exchanger类也能完成响应的功能。</li>
</ul>
</li>
<li>Lists类<ul>
<li>CopyOnWriteArrayList ： list的实现每一次都会产生一个新的隐含数组副本，所以这个操作成本很高，适合遍历操作比更新操作多的集合，例如listeners/observers集合</li>
</ul>
</li>
<li>Collections 工具类<ul>
<li>checked* : 检查要添加的元素的类型并返回结果，尝试添加非法类型的变量都会抛出一个ClassCastException<ul>
<li>checkedCollection</li>
<li>checkedList</li>
<li>checkedMap</li>
<li>checkSet</li>
<li>checkedSortedMap</li>
<li>checkedSortedSet</li>
</ul>
</li>
<li>empty* : 返回一个固定的空集合。<ul>
<li>emptyList</li>
<li>emptyMap</li>
<li>emptySet</li>
</ul>
</li>
<li>singleton* : 返回一个只有一个入口的set、list、map集合<ul>
<li>singletonList</li>
<li>singletonMap</li>
</ul>
</li>
<li>synchronized* ： 获得集合的线程安全版本<ul>
<li>synchronizedCollection</li>
<li>synchronizedList</li>
<li>synchronizedMap</li>
<li>synchronizedSet</li>
<li>synchronizedSortedMap</li>
<li>synchronizedSortedSet</li>
</ul>
</li>
<li>unmodifiable* : 返回一个不可变的集合<ul>
<li>unmodifiableCollection</li>
<li>unmodifiableList</li>
<li>unmodifiableMap</li>
<li>unmodifiableSet</li>
<li>unmodifiableSortedMap</li>
<li>unmodifiableSortedSet</li>
</ul>
</li>
<li>addAll : 添加一些元素或者一个数组的内容到集合中</li>
<li>binarySearch ： 和数组的Arrays.binarySearch功能相同</li>
<li>disjoint : 检查两个集合是不是没有相同元素</li>
<li>fill ： 用一个指定的值代替集合中的所有元素</li>
<li>frequency: 集合中有多少元素是和给定元素相同的。</li>
<li>indexOfSubList、lastIndexOfSubList\indexOf\lashIndexOf 找出给定list中第一个出现和最后一个出现的子表</li>
<li>max、min 找出基于自然顺序或者比较器排序的集合、最大或者最小的元素</li>
<li>replaceAll： 替换所有</li>
<li>reverse: 掉到排序元素和集合中的顺序</li>
<li>rotate ： 根据给定的距离旋转元素</li>
<li>shuffle： 随机排放List集合中的节点，而已给定自己的生成器</li>
<li>sort ： 自然排序或者指定的排序器排序</li>
<li>swap 交换集合中的两个元素的位置</li>
</ul>
</li>
<li>Arrays<ul>
<li>Arrays.asList(): 可以将Array转换成List。</li>
<li>Arrays.binarySearch : 在一个已排序的或者其中一段中快速查找</li>
<li>Arrays.copyOf : 如果扩大数组容量又不想改变内容时候用这个方法</li>
<li>Arrays.copyOfRange :  可以复制整个数组或者其中一个部分</li>
<li>Arrays.deepEquals、Arrays.deepHashCode : Arrays.equals、hashCode的高级版本，支持子数据操作。</li>
<li>Arrays.equals : 比较两个数组是否想相等。</li>
<li>Arrays.fill  : 用一个给定的值填充整个数组或者其中一个部分</li>
<li>Arrays.hashCode : 根据数组内容计算器hash值。</li>
<li>Arrays.sort : 对整个数组或者数组一部分进行排序。</li>
<li>Arrays.toString : 打印数组的内容</li>
<li>所有集合都可以用 T[] Collection.toArray(T[] a)方法复制到整个数组：<br>  return coll.toArray(new T[coll.size()]);</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>并发和多线程<ul>
<li>线程池</li>
<li>SYNC</li>
<li>Lock机制</li>
<li>线程通信</li>
<li>volatile</li>
<li>ThreadLocal</li>
<li>CyclicBarrier</li>
<li>Atomic包</li>
<li>concurrent包</li>
<li>CountDownlatch</li>
<li>AQS</li>
<li>CAS</li>
</ul>
</li>
<li>JVM<ul>
<li>内存模型</li>
<li>GC垃圾回收机制</li>
<li>分代算法，GC算法</li>
<li>收集器</li>
<li>类加载、双亲委派</li>
<li>JVM调优<ul>
<li>jvm参数</li>
</ul>
</li>
<li>内存泄露和内存溢出</li>
</ul>
</li>
<li>IO和NIO</li>
<li>反射和代理、异常、java8、序列化</li>
<li>设计模式：<ul>
<li>24中常用的设计模式</li>
<li>java源码中或者spring中用到哪些</li>
</ul>
</li>
<li>web<ul>
<li>servlet</li>
<li>cookie、session</li>
<li>spring<ul>
<li>aop</li>
<li>ioc</li>
<li>mvc</li>
<li>事务</li>
<li>动态代理</li>
</ul>
</li>
<li>mybatis</li>
<li>tomcat<ul>
<li>类加载机制</li>
</ul>
</li>
<li>hibernate</li>
</ul>
</li>
<li>源码</li>
<li>Guava<h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3></li>
<li>python</li>
<li>shell</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul>
<li>CAP原理和BASE理论</li>
<li>NoSql和KV存储(redis,hbase,mongodb,etcd,springcloud)</li>
<li>负载均衡(原理，cdn，一致性hash)</li>
<li>RPC框架<ul>
<li>通信 netty</li>
<li>序列化协议 thrift，protobuff</li>
</ul>
</li>
<li>消息队列<ul>
<li>原理</li>
<li>kafka</li>
<li>activeMQ</li>
<li>rocketMQ</li>
</ul>
</li>
<li>分布式存储系统<ul>
<li>GFS</li>
<li>HDFS</li>
<li>fastDFS</li>
<li>存储模型<ul>
<li>skipList</li>
<li>LSM</li>
</ul>
</li>
</ul>
</li>
<li>分布式事务<ul>
<li>redis分布锁</li>
</ul>
</li>
<li><p>分布式锁</p>
<h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3></li>
<li>hadoop生态圈<ul>
<li>hive</li>
<li>hbase</li>
<li>hdfs</li>
<li>zoopkeeper</li>
<li>storm</li>
<li>kafka</li>
</ul>
</li>
<li>spark</li>
<li>搜索引擎与技术</li>
<li>机器学习与技术</li>
<li>人工智能</li>
</ul>
<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><ul>
<li>算法与数据结构<ul>
<li>数据结构（严蔚敏）/大话数据结构              * 剑指Offer/程序员面试金典/编程珠玑/编程之美/牛客网+leetcode</li>
<li>程序员笔试面试最优解（左程云）/不如直接看左神的笔试面试指南视频</li>
<li>数据结构与算法经典问题解析（Java语言描述）</li>
<li>图解数据结构（使用Java）</li>
</ul>
</li>
<li>计算机网络：<ul>
<li>计算机网络（谢希仁）</li>
<li>TCP/IP 详解</li>
<li>HTTP权威指南</li>
<li>图解TCP/IP</li>
<li>图解HTTP</li>
</ul>
</li>
<li>数据库：//数据库主要是多用，书上主要看索引和性能的部分<ul>
<li>高性能MySQL/深入浅出MySQL</li>
</ul>
</li>
<li>操作系统：<ul>
<li>OS原理：操作系统（课本，黑色的那个）</li>
<li>Linux：<ul>
<li>Linux私房菜 //鸟哥写的，很全，包括bash部分</li>
<li>跟阿铭学Linux //主要偏重于命令和操作，比较浅显</li>
</ul>
</li>
</ul>
</li>
<li>java：<ul>
<li>Java疯狂讲义/Java编程思想/Java核心技术 卷1</li>
<li>深入理解Java虚拟机</li>
<li>并发编程的艺术/多线程编程核心技术</li>
<li>Effective Java</li>
<li>Java程序员面试笔试宝典 //何昊的那本，个人感觉是突击知识点的神器</li>
<li>Java程序性能优化</li>
<li>实战Java高并发程序设计</li>
</ul>
</li>
<li>Java Web：<ul>
<li>Spring实战/轻量级JavaEE 企业应用（红皮，讲SSH的） //主要看最后一部分Spring的就可以</li>
<li>深入JavaWeb技术内幕（阿里 许令波）//这个讲的还是比较深的</li>
<li>SpringBoot实战/深入实践SpringBoot</li>
</ul>
</li>
<li>设计模式：<ul>
<li>大话设计模式 //通俗易懂</li>
<li>各类博客的总结</li>
</ul>
</li>
<li>分布式与大数据：<ul>
<li>分布式服务框架原理与实践</li>
<li>大型网站技术架构</li>
<li>Hadoop实战（hadoop体系包括得很全）</li>
</ul>
</li>
<li>其他：<ul>
<li>Git：<ul>
<li>Git权威指南</li>
<li>Git官方讲解视频（牛客网有带字幕的）</li>
</ul>
</li>
<li>Redis：<ul>
<li>Redis实战</li>
</ul>
</li>
</ul>
</li>
<li>docker</li>
<li>springcloud</li>
</ul>
<p>感谢：<br><a href="https://www.nowcoder.com/discuss/29890?hmsr=toutiao.io&amp;source=rss&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">这可能不只是一篇面经</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[高可用+高并发+负载均衡架构设计(转发)]]></title>
      <url>/2017/09/08/%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%BD%AC%E5%8F%91/</url>
      <content type="html"><![CDATA[<p><img src="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960393&amp;idx=1&amp;sn=23cf8438b436c531c81b3f09a3d5e8fb&amp;chksm=bd2d01958a5a88838e6ef493ccb1fe0854f7216f3863fbe9798eec5019dc58d73d4e95b3132f&amp;mpshare=1&amp;scene=1&amp;srcid=09082gOCvZ5mjeN9YZ8HSg0o#rd" alt="原地址"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[微信机器人流程]]></title>
      <url>/2017/09/03/%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="获取uuid和二维码："><a href="#获取uuid和二维码：" class="headerlink" title="获取uuid和二维码："></a>获取uuid和二维码：</h2><ul>
<li>在公众号输入8，即可返回二维码图片；<ul>
<li>生成uuid；</li>
<li>生成二维码；</li>
<li>redis中保存要登陆用户的信息；</li>
<li>返回二维码。</li>
</ul>
</li>
</ul>
<h2 id="后台守护进程："><a href="#后台守护进程：" class="headerlink" title="后台守护进程："></a>后台守护进程：</h2><ul>
<li>开启一个守护线程：<ul>
<li>获取redis中保存的用户信息；</li>
<li>判断如果未登陆则继续执行以下操作，如果已经登陆了，返回，不做任何操作。</li>
<li>loginService.login()<ul>
<li>代码登陆逻辑，如果登陆了，将状态setAlive置为已经登陆，若未登陆，sleep1秒继续。</li>
<li>将联系人信息保存到redis中</li>
</ul>
</li>
<li>webWxInit()<ul>
<li>获取user信息，并保存到数据库。</li>
<li>获取用户的联系人信息，并保存到数据库；</li>
<li>获取SyncKeyBean信息，并保存到数据库；</li>
</ul>
</li>
<li>wxStatusNotify()<ul>
<li>微信通知状态改变，手机端提示网页端登陆成功。</li>
</ul>
</li>
<li>startReceiving()<ul>
<li>开启消息接收。</li>
<li>开启新线程：<ul>
<li>syncCheck() 检查是否有新消息<ul>
<li>状态为0(收到正常报文)：<ul>
<li>webWxSync() 联网获取新消息；<ul>
<li>通过初始化过去的SyncKey参数进行获取，返回成功后，要把新返回的SyncKey保存到数据库中，下次用新SyncKey进行获取新信息。</li>
<li>对获取到的新信息进行操作。 MsgCenter.produceMsg();</li>
<li>保存消息到数据库。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>webWxGetContact() 获取好友列表</li>
<li>WebWxBatchGetContact()</li>
<li>setUserInfo() 缓存本次好友信息。</li>
<li>CheckLoginStatusThread开启登陆状态线程。</li>
</ul>
</li>
</ul>
<h2 id="2017-09-04"><a href="#2017-09-04" class="headerlink" title="2017.09.04"></a>2017.09.04</h2><p>  做好微信机器人，在微信公众平台界面发送8将返回一个二维码，扫码登陆后即可开启机器人。<br>  机器人功能： //TODO</p>
<pre><code>* 集成聊天机器人功能。
* 备份聊天记录。
* 爬取所有用户，并分析用户联系人的男女比例，整合头像。
* 爬取公众号文章。
* 撤回消息备份
* 关键词监听
* 消息搜索
* 信息分析
* 查看/删除文件[文件名] e.g. 查看文件[123345234.mp3]
* 撤回附件列表 (查看都有哪些保存在电脑中的已撤回附件)
* 清空附件列表 (清空已经保存在电脑中的附件)
* 添加关键词[关键词] e.g. 设置关键词[在不在]
* 删除关键词[关键词] e.g. 删除关键词[在不在]
* 清空关键词 清空已经设置的所有关键词
* 查看关键词 查看目前设置的关键词
* 添加签到口令#公众号:签到口令# e.g. 添加签到口令#招商银行信用卡:签到#
* 删除签到口令#公众号# e.g. 删除签到口令#招商银行信用卡#
* 查看签到口令 查看已经存在的公众和和对应的签到口令
* 清空签到口令 清空所有签到口令
* 截图 截取当前屏幕发送到文件助手
* 添加自动回复#针对的关键词:回复内容# e.g.添加自动回复#在不在:我现在有事情，待会儿回复你#
* 删除自动回复#针对的关键词# e.g.删除自动回复#在不在#
* 清空自动回复 清空所有的自定义回复规则
* 关闭自动回复
* 打开自动回复
* 退出程序
</code></pre><h2 id="备份聊天功能："><a href="#备份聊天功能：" class="headerlink" title="备份聊天功能："></a>备份聊天功能：</h2><pre><code>* 发送 “开启**回复” 即可回复 ** 信息
  后台将配置记录到sql中，并缓存到redis中。
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql引擎myisam和innodb的异同]]></title>
      <url>/2017/08/16/Mysql%E5%BC%95%E6%93%8Emyisam%E5%92%8Cinnodb%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      <content type="html"><![CDATA[<h2 id="myisam和innodb不同之处"><a href="#myisam和innodb不同之处" class="headerlink" title="myisam和innodb不同之处"></a>myisam和innodb不同之处</h2><ul>
<li>1事务的支持不同：<ul>
<li>innodb支持事务；</li>
<li>myisam不支持事务；</li>
</ul>
</li>
<li>2锁粒度<ul>
<li>indodb行锁应用</li>
<li>myisam表锁</li>
</ul>
</li>
<li>3存储空间<ul>
<li>innodb既缓存索引文件又缓存数据文件；</li>
<li>myisam只缓存索引文件。</li>
</ul>
</li>
<li>4存储结构<ul>
<li>myisam数据文件的扩展名为.myd myData，索引文件的扩展名是.myi myIndex</li>
<li>innodb所有的表都保存在同一个数据文件里面 即为 .ibd</li>
</ul>
</li>
<li>统计记录行数<ul>
<li>myisam保存表的总行数，select count(*) from table 会直接取出该值</li>
<li>innodb没有保存表的中行书，select count(*) from table 就会遍历整个表，消耗相当大。</li>
</ul>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap全解析]]></title>
      <url>/2017/08/09/HashMap%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>HashMap实现了Map接口，继承自AbstactMap。其中Map接口定义了键映射到值的规则。<br>    public class HashMap<k,v><br>    extends AbstractMap<k,v><br>    implements Map<k,v>, Cloneable, Serializable<br>    <img src="../img/java.util.map类图.png" alt=""><br><em>注意</em></k,v></k,v></k,v></p>
<pre><code>* HashMap: 它根据键的hashCode值存储数据，大多数情况下可以直接定位到他的值，因此有很乖的访问速度，但是遍历的顺序是不确定的，HashMap最多只允许一条记录为null，允许多条记录的值为null，HashMap不是线程安全的，即任意时刻有多线程同时写HashMap可能会导致数据不一致问题。
* HashTable: HashTable是遗留类，很多映射的功能和HashMap类似，但是他是继承自Dictionary类，并且是线程安全的，任何时间只有一个线程能写hashTable。
* ConcurrentHashMap：
* LinkedHashMap: 是HashMap的一个自雷，保存了插入顺序，在用iterator遍历LinkedHashMap时，先得到的肯定是新插入的，也可以在构造式带参数，按照访问次数进行排序。
* TreeMap: TreeMap实现了SortMap接口，能够把保存的记录根据键排序，默认是按照键值升序排序，也可以指定排序的比较器，在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出ClassCastExeption。
</code></pre><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li>HashMap()：默认构造器，构造一个初始容量为10和默认加载银子为0.75的空HashMap</li>
<li>HashMap(int initialCapacity):构造一个指定容量的和默认加载银子为0.75的空HashMap</li>
<li>HashMap(int initialCapacity, float loadFactor)： 构造一个指定初始容量和加载银子的空HashMap；<br><em>其中initialCapacity不能小于0，当它大于1 &lt;&lt; 30的时候，它就等于1 &lt;&lt; 30</em><br>   if (initialCapacity &gt; MAXIMUM_CAPACITY)<pre><code>initialCapacity = MAXIMUM_CAPACITY;
</code></pre></li>
</ul>
<p>初始容量：代表哈希表中通的数量，<br>加载因子： 代表哈希表在自动增加之前可以达到的尺度。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>列表散列：<br><img src="http://images.cnitblog.com/blog/381060/201401/152128351581.png" alt=""><br>数组+链表+红黑树(jdk8中增加红黑树)<br><img src="../img/hashMap内存结构.png" alt=""><br>HashMap的底层实现还是数组，只不过数组的每一项都是一条链，其中initialCapacity参数代表了该数组额长度。<br>     /**</p>
<pre><code> * Returns a power of two size for the given target capacity.
 */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre><p>这一段表示将初始容量变成向下靠近2的幂次方的数。</p>
<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final int hash;    //用来定位数组索引位置</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K,V&gt; next;   //链表的下一个node</div><div class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">    public final K getKey()&#123; ... &#125;</div><div class="line">    public final V getValue() &#123; ... &#125;</div><div class="line">    public final String toString() &#123; ... &#125;</div><div class="line">    public final int hashCode() &#123; ... &#125;</div><div class="line">    public final V setValue(V newValue) &#123; ... &#125;</div><div class="line">    public final boolean equals(Object o) &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（键值对）。</p>
<p>HashMap就是使用哈希表来存储的，哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，java中HashMap采用了链地址法，简单来说就是数组加链表的结合。在每个数组元素都是一个链表结构，当数据被hash后，得到数组下标，把数据放在对应下标元素的链表上，例如：<br>    <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">系统将&quot;name&quot;这个key的HashCode()方法得到其hashCode值，然后再通过Hash算法的后两步运算（高位运算和取模运算）来定位该键值对应的存储位置，有时候两个key会定位到相同的位置，表示发生了Hash碰撞，当然hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map存取效率就会更高。</div><div class="line">如果哈希桶数很大，即使较差的hash算法也会比较分散，如果哈希桶数组很小，就很容易发生碰撞。</div><div class="line"></div><div class="line"># 容量</div><div class="line">在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</div></pre></td></tr></table></figure></p>
<pre><code>int threshold;             // 所能容纳的key-value对极限 
final float loadFactor;    // 负载因子
int modCount;  
int size;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">首先，Node[] table的初始化长度length为默认16，loadFactor为负载因子，默认为0.75.threshold是HashMap所能容纳的最大数据量的Node（键值对）个数。threshold=length*loadFactor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</div><div class="line"></div><div class="line">* size：实际存在的键值对数量</div><div class="line">* threshold：length*loadFactor</div><div class="line">* modCount：记录HashMap内部结构发生裱花的次数，主要用于迭代的快速失败，内部结构变化指的是结构发生变化，比如put，但是某个key对应的value值被覆盖部署于结构变化。</div><div class="line"></div><div class="line">在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</div><div class="line"></div><div class="line">这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考。</div><div class="line">[http://blog.csdn.net/v_july_v/article/details/6105630。](http://blog.csdn.net/v_july_v/article/details/6105630。)</div><div class="line"></div><div class="line">#方法</div><div class="line">* 确定哈希桶数组索引位置。</div><div class="line">  不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步，</div></pre></td></tr></table></figure>
<pre><code>方法一：
</code></pre><p>static final int hash(Object key) {   //jdk1.8 &amp; jdk1.7<br>     int h;<br>     // h = key.hashCode() 为第一步 取hashCode值<br>     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算<br>     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}<br>方法二：<br>static int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的<br>     return h &amp; (length-1);  //第三步 取模运算<br>}<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</div><div class="line"></div><div class="line">这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</div><div class="line">* put方法</div><div class="line">![](../img/hashMap put方法执行流程图.png)</div></pre></td></tr></table></figure></p>
<pre><code>public V put(K key, V value) {
</code></pre><p> 2     // 对key的hashCode()做hash<br> 3     return putVal(hash(key), key, value, false, true);<br> 4 }<br> 5<br> 6 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br> 7                boolean evict) {<br> 8     Node<k,v>[] tab; Node<k,v> p; int n, i;<br> 9     // 步骤①：tab为空则创建<br>10     if ((tab = table) == null || (n = tab.length) == 0)<br>11         n = (tab = resize()).length;<br>12     // 步骤②：计算index，并对null做处理<br>13     if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>14         tab[i] = newNode(hash, key, value, null);<br>15     else {<br>16         Node<k,v> e; K k;<br>17         // 步骤③：节点key存在，直接覆盖value<br>18         if (p.hash == hash &amp;&amp;<br>19             ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>20             e = p;<br>21         // 步骤④：判断该链为红黑树<br>22         else if (p instanceof TreeNode)<br>23             e = ((TreeNode<k,v>)p).putTreeVal(this, tab, hash, key, value);<br>24         // 步骤⑤：该链为链表<br>25         else {<br>26             for (int binCount = 0; ; ++binCount) {<br>27                 if ((e = p.next) == null) {<br>28                     p.next = newNode(hash, key,value,null);<br>                        //链表长度大于8转换为红黑树进行处理<br>29                     if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st<br>30                         treeifyBin(tab, hash);<br>31                     break;<br>32                 }<br>                    // key已经存在直接覆盖value<br>33                 if (e.hash == hash &amp;&amp;<br>34                     ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                                            break;<br>36                 p = e;<br>37             }<br>38         }<br>40         if (e != null) { // existing mapping for key<br>41             V oldValue = e.value;<br>42             if (!onlyIfAbsent || oldValue == null)<br>43                 e.value = value;<br>44             afterNodeAccess(e);<br>45             return oldValue;<br>46         }<br>47     }</k,v></k,v></k,v></k,v></p>
<p>48     ++modCount;<br>49     // 步骤⑥：超过最大容量 就扩容<br>50     if (++size &gt; threshold)<br>51         resize();<br>52     afterNodeInsertion(evict);<br>53     return null;<br>54 }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#扩容（resize）</div></pre></td></tr></table></figure>
<pre><code>1 void resize(int newCapacity) {   //传入新的容量
2     Entry[] oldTable = table;    //引用扩容前的Entry数组
</code></pre><p> 3     int oldCapacity = oldTable.length;<br> 4     if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了<br> 5         threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了<br> 6         return;<br> 7     }<br> 8<br> 9     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组<br>10     transfer(newTable);                         //！！将数据转移到新的Entry数组里<br>11     table = newTable;                           //HashMap的table属性引用新的Entry数组<br>12     threshold = (int)(newCapacity * loadFactor);//修改阈值<br>13 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</div></pre></td></tr></table></figure></p>
<p>1 void transfer(Entry[] newTable) {<br> 2     Entry[] src = table;                   //src引用了旧的Entry数组<br> 3     int newCapacity = newTable.length;<br> 4     for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组<br> 5         Entry<k,v> e = src[j];             //取得旧Entry数组的每个元素<br> 6         if (e != null) {<br> 7             src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）<br> 8             do {<br> 9                 Entry<k,v> next = e.next;<br>10                 int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置<br>11                 e.next = newTable[i]; //标记[1]<br>12                 newTable[i] = e;      //将元素放在数组上<br>13                 e = next;             //访问下一个Entry链上的元素<br>14             } while (e != null);<br>15         }<br>16     }<br>17 }</k,v></k,v></p>
<p>```</p>
<h2 id="感谢参考"><a href="#感谢参考" class="headerlink" title="感谢参考"></a>感谢参考</h2><p><a href="http://www.importnew.com/20386.html" target="_blank" rel="external">参考</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[这可能不只是一篇面经(转发)]]></title>
      <url>/2017/08/01/%E8%BF%99%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%8F%AA%E6%98%AF%E4%B8%80%E7%AF%87%E9%9D%A2%E7%BB%8F-%E8%BD%AC%E5%8F%91/</url>
      <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/29890?hmsr=toutiao.io&amp;source=rss&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">原文链接在此</a></p>
<p>mark，有很多地方还是需要学习的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud使用docker部署注册eureka找不到地址]]></title>
      <url>/2017/07/31/SpringCloud%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%B3%A8%E5%86%8Ceureka%E6%89%BE%E4%B8%8D%E5%88%B0%E5%9C%B0%E5%9D%80/</url>
      <content type="html"><![CDATA[<p>跟随大神学习SpringCloud的时候，在使用docker部署时，遇到了提供者注册不到eureka上去，<a href="http://blog.csdn.net/forezp/article/details/70198649#reply" target="_blank" rel="external">教程地址在此</a></p>
<p>之后我搜了下docker进程间通信找到了一个<strong>解决办法</strong>：</p>
<p>我弄了一整天也是一直注册不进去，后来又搜了搜docker进程间通信，发现一个方法，<br>eureka-server部署的时候给一个名字： docker run –name eureka-server -p 8761:8761<br>server-hi中部署使用link参数 docker run –link eureka-server（server部署时赋予的名字）:eureka-server(配置中写的地址) ……<br>注册不进去的可以试试。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库的count的区别]]></title>
      <url>/2017/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84count%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[springBot配置大全（转载）]]></title>
      <url>/2017/07/28/springBot%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[七大查找算法]]></title>
      <url>/2017/07/27/%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.jobbole.com/111629/" target="_blank" rel="external">原文链接</a></p>
<h3 id="查找算法分类："><a href="#查找算法分类：" class="headerlink" title="查找算法分类："></a>查找算法分类：</h3><ul>
<li>1）静态查找和动态查找；<br> 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</li>
<li>2）无序查找和有序查找。<ul>
<li>无序查找：被查找数列有序无序均可；</li>
<li>有序查找：被查找数列必须为有序数列。</li>
</ul>
</li>
</ul>
<h2 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h2><p>   挨个查找，不用多说，时间复杂度为O(n);</p>
<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><ul>
<li><p>说明元素必须是有序的，如果是无序的则要先进行排序操作。</p>
</li>
<li><p>基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。     </p>
</li>
<li>复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">    //二分查找（折半查找），版本1</div><div class="line">int BinarySearch1(int a[], int value, int n)</div><div class="line">&#123;</div><div class="line"> int low, high, mid;</div><div class="line"> low = 0;</div><div class="line"> high = n-1;</div><div class="line"> while(low&lt;=high)</div><div class="line"> &#123;</div><div class="line">     mid = (low+high)/2;</div><div class="line">     if(a[mid]==value)</div><div class="line">     return mid;</div><div class="line">     if(a[mid]&gt;value)</div><div class="line">     high = mid-1;</div><div class="line">     if(a[mid]&lt;value)</div><div class="line">     low = mid+1;</div><div class="line"> &#125;</div><div class="line">     return -1;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">//二分查找，递归版本</div><div class="line">int BinarySearch2(int a[], int value, int low, int high)</div><div class="line">&#123;</div><div class="line">   int mid = low+(high-low)/2;</div><div class="line">   if(a[mid]==value)</div><div class="line">   return mid;</div><div class="line">   if(a[mid]&gt;value)</div><div class="line">   return BinarySearch2(a, value, low, mid-1);</div><div class="line">   if(a[mid]&lt;value)</div><div class="line">   return BinarySearch2(a, value, mid+1, high);</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">## 3. 插值查找</div><div class="line"></div><div class="line">在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</div><div class="line"></div><div class="line">打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。&lt;</div><div class="line"></div><div class="line">同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</div><div class="line"></div><div class="line">经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</div><div class="line"></div><div class="line">mid=(low+high)/2, 即mid=low+1/2*(high-low);</div><div class="line"></div><div class="line">通过类比，我们可以将查找的点改进为如下：</div><div class="line"></div><div class="line">mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，</div><div class="line"></div><div class="line">也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</div><div class="line"></div><div class="line">* 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</div><div class="line"></div><div class="line">* 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</div><div class="line">**如果分布比较均匀，插值查找比二分查找快，如果分布不均匀，二分查找比较快**</div><div class="line">* 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>//插值查找<br>int InsertionSearch(int a[], int value, int low, int high)<br>{<br>     int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);<br>     if(a[mid]==value)<br>        return mid;<br>     if(a[mid]&gt;value)<br>        return InsertionSearch(a, value, low, mid-1);<br>     if(a[mid]<value) return="" insertionsearch(a,="" value,="" mid+1,="" high);="" }="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 4. 斐波那契查找</div><div class="line"></div><div class="line">在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</div><div class="line"></div><div class="line">黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</div><div class="line"></div><div class="line">0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</div><div class="line"></div><div class="line">大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</div><div class="line"></div><div class="line"></div><div class="line">* 基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</div><div class="line"></div><div class="line">相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</div><div class="line">   * 1）相等，mid位置的元素即为所求</div><div class="line"></div><div class="line">   * 2）&gt;，low=mid+1;</div><div class="line"></div><div class="line">   * 3）&lt;，high=mid-1。</div><div class="line"></div><div class="line">斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</div><div class="line"></div><div class="line">开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</div><div class="line"></div><div class="line">   * 1）相等，mid位置的元素即为所求</div><div class="line"></div><div class="line">   * 2）&gt;，low=mid+1,k-=2;</div><div class="line"></div><div class="line">说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</div><div class="line"></div><div class="line">   * 3）&lt;，high=mid-1,k-=1。</div><div class="line"></div><div class="line">说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</div><div class="line"></div><div class="line">复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</div><div class="line"></div><div class="line">```const int max_size=20;//斐波那契数组的长度</div><div class="line">    </div><div class="line">   /*构造一个斐波那契数组*/</div><div class="line">   void Fibonacci(int * F)</div><div class="line">   &#123;</div><div class="line">      F[0]=0;</div><div class="line">      F[1]=1;</div><div class="line">      for(int i=2;i&lt;max_size;++i)</div><div class="line">      F[i]=F[i-1]+F[i-2];</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">   /*定义斐波那契查找法*/</div><div class="line">   int FibonacciSearch(int *a, int n, int key) //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</div><div class="line">   &#123;</div><div class="line">      int low=0;</div><div class="line">      int high=n-1;</div><div class="line">    </div><div class="line">      int F[max_size];</div><div class="line">      Fibonacci(F);//构造一个斐波那契数组F</div><div class="line">    </div><div class="line">      int k=0;</div><div class="line">      while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置</div><div class="line">      ++k;</div><div class="line">    </div><div class="line">      int * temp;//将数组a扩展到F[k]-1的长度</div><div class="line">      temp=new int [F[k]-1];</div><div class="line">      memcpy(temp,a,n*sizeof(int));</div><div class="line">    </div><div class="line">      for(int i=n;i&lt;F[k]-1;++i)</div><div class="line">      temp[i]=a[n-1];</div><div class="line">    </div><div class="line">      while(low&lt;=high)</div><div class="line">   &#123;</div><div class="line">      int mid=low+F[k-1]-1;</div><div class="line">      if(key&lt;temp[mid])</div><div class="line">   &#123;</div><div class="line">      high=mid-1;</div><div class="line">      k-=1;</div><div class="line">   &#125;</div><div class="line">      else if(key&gt;temp[mid])</div><div class="line">   &#123;</div><div class="line">      low=mid+1;</div><div class="line">      k-=2;</div><div class="line">   &#125;</div><div class="line">      else</div><div class="line">   &#123;</div><div class="line">      if(mid&lt;n)</div><div class="line">      return mid; //若相等则说明mid即为查找到的位置</div><div class="line">      else</div><div class="line">      return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1</div><div class="line">   &#125;</div><div class="line">   &#125;</div><div class="line">      delete [] temp;</div><div class="line">      return -1;</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">      int main()</div><div class="line">   &#123;</div><div class="line">      int a[] = &#123;0,16,24,35,47,59,62,73,88,99&#125;;</div><div class="line">      int key=100;</div><div class="line">      int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);</div><div class="line">      cout&lt;&lt;key&lt;&lt;&quot; is located at:&quot;&lt;&lt;index;</div><div class="line">      return 0;</div><div class="line">   &#125;</div></pre></td></tr></table></value)></p>
<h2 id="5-树表查找"><a href="#5-树表查找" class="headerlink" title="5. 树表查找"></a>5. 树表查找</h2><p>  ###5.1 最简单的树表查找算法——二叉树查找算法。</p>
<ul>
<li><p>基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</p>
<p>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<p>1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>3）任意节点的左、右子树也分别为二叉查找树。</p>
<p>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</p>
<p>不同形态的二叉查找树如下图所示：</p>
<ul>
<li>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</li>
</ul>
</li>
</ul>
<p>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p>
<h3 id="5-2-平衡查找树之2-3查找树（2-3-Tree）"><a href="#5-2-平衡查找树之2-3查找树（2-3-Tree）" class="headerlink" title="5.2 平衡查找树之2-3查找树（2-3 Tree）"></a>5.2 平衡查找树之2-3查找树（2-3 Tree）</h3><p>2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：</p>
<ul>
<li><p>1）要么为空，要么：</p>
</li>
<li><p>2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</p>
</li>
<li><p>3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。   </p>
</li>
<li><p>2-3查找树的性质：</p>
<p>1）如果中序遍历2-3查找树，就可以得到排好序的序列；</p>
<p>2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</p>
<ul>
<li>复杂度分析：</li>
</ul>
<p>2-3树的查找效率与树的高度是息息相关的。</p>
<p>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN<br>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN<br>距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p>
</li>
</ul>
<h3 id="5-3-平衡查找树之红黑树（Red-Black-Tree）"><a href="#5-3-平衡查找树之红黑树（Red-Black-Tree）" class="headerlink" title="5.3 平衡查找树之红黑树（Red-Black Tree）"></a>5.3 平衡查找树之红黑树（Red-Black Tree）</h3><p>  2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>
<p>  基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[跳跃表]]></title>
      <url>/2017/07/27/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.jobbole.com/111731/" target="_blank" rel="external">看这篇文章</a></p>
<p>和B+树很像，不过B+树插入需要Rebalance进行树重调整。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql索引B+树]]></title>
      <url>/2017/07/27/Mysql%E7%B4%A2%E5%BC%95B-%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.jobbole.com/111757/" target="_blank" rel="external">看这篇文章讲的很好</a></p>
<h2 id="B-树（Balance-Tree）"><a href="#B-树（Balance-Tree）" class="headerlink" title="B - 树（Balance Tree）"></a>B - 树（Balance Tree）</h2><pre><code>二叉查找树的时间复杂度是O(log(n)) 已经够快了，但是二叉查找树的查找速度取决于树的高度。
B - 树，每个节点包含最多k个孩子，k被称为阶，k的大小取决于磁盘页的大小。
</code></pre><h3 id="一个-m-阶的-B-树具有如下几个特征"><a href="#一个-m-阶的-B-树具有如下几个特征" class="headerlink" title="一个 m 阶的 B 树具有如下几个特征"></a>一个 m 阶的 B 树具有如下几个特征</h3><ul>
<li>根节点至少有两个子女。 </li>
<li>每个中间节点包含k-1个元素和k个孩子，其中m/2 &lt;= k &lt;= m</li>
<li>每个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;=m</li>
<li>所有叶子节点都位于同一层</li>
<li>每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>   在b-树基础上进行改造，将索引全部建在叶子节点上，非叶子节点指向叶子节点的大小。</p>
<p>   <a href="http://blog.jobbole.com/105644/" target="_blank" rel="external">看这篇文章</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[100块钱可以兑换50块、10块、5块、1块的算法]]></title>
      <url>/2017/07/26/100%E5%9D%97%E9%92%B1%E5%8F%AF%E4%BB%A5%E5%85%91%E6%8D%A250%E5%9D%97%E3%80%8110%E5%9D%97%E3%80%815%E5%9D%97%E3%80%811%E5%9D%97%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="最先想到的当然是for循环了："><a href="#最先想到的当然是for循环了：" class="headerlink" title="最先想到的当然是for循环了："></a>最先想到的当然是for循环了：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">   long time1 = System.currentTimeMillis();</div><div class="line">           System.out.println(&quot;当前时间为&quot;+time1);</div><div class="line">           int n = 0;</div><div class="line">           int n1, n5, n10, n50;</div><div class="line">           for (n1 = 0; n1 &lt; 100; n1++) &#123;</div><div class="line">               for (n5 = 0; n5 &lt; 20; n5++) &#123;</div><div class="line">                   for (n10 = 0; n10 &lt; 10; n10++) &#123;</div><div class="line">                       for (n50 = 0; n50 &lt; 2; n50++) &#123;</div><div class="line">                           if (n1 * 1 + n5 * 5 + n10 * 10 + n50 * 50 == 100) &#123;</div><div class="line">                               n++;</div><div class="line">                               System.out.println(&quot;1块的：&quot; + n1 + &quot;张 5块的： &quot; + n5 + &quot;张 10块的 ：&quot; + n10 + &quot;张 50块的：&quot; + n50 + &quot;张&quot;);</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           long time2 = System.currentTimeMillis();</div><div class="line">           System.out.println(&quot;结束时间为&quot;+time2);</div><div class="line">           long time = time2 - time1;</div><div class="line">           System.out.println(n + &quot; 耗费时间为 &quot; + time);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>很容易得出结果154.但是耗费时间为 1501038954420 - 1501038954413 =7;
虽然时间耗费不是很多，但是通过打印信息可以看出来，50为2的时候只有一种情况，却空跑了很多空循环。
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud学习5路由网关(zuul)]]></title>
      <url>/2017/07/21/SpringCloud%E5%AD%A6%E4%B9%A05%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3-zuul/</url>
      <content type="html"><![CDATA[<p>在微服务架构中，需要几个关键的组件，服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个组件可以组建一个简单的微服务架构，如下图：</p>
<p><img src="img/路由网关.png" alt="image"></p>
<p>注意：A 服务和 B 服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。</p>
<p>客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul 集群），然后再到具体的服务，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在 Git 仓库，方便开发人员随时改配置。</p>
<p>一、Zuul 简介</p>
<p>Zuul 的主要功能是路由和过滤器。路由功能是微服务的一部分，比如／api/user 映射到 user 服务，/api/shop 映射到 shop 服务。zuul 实现了负载均衡。</p>
<p>zuul 有以下功能：</p>
<p>Authentication<br>Insights<br>Stress Testing<br>Canary Testing<br>Dynamic Routing<br>Service Migration<br>Load Shedding<br>Security<br>Static Response handling<br>Active/Active traffic management</p>
<p>二、准备工作</p>
<p>继续使用上一节的工程。在原有的工程上，创建一个新的工程。</p>
<p>三、创建 service-zuul 工程</p>
<pre><code>&lt;dependency&gt;
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
   &lt;/dependency&gt;

   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
       &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;
</code></pre><p>在其入口 applicaton 类加上注解 @EnableZuulProxy，开启 zuul：</p>
<p>filterType：返回一个字符串代表过滤器的类型，在 zuul 中定义了四种不同生命周期的过滤器类型，具体如下：<br>pre：路由之前<br>routing：路由之时<br>post： 路由之后<br>error：发送错误调用<br>filterOrder：过滤的顺序<br>shouldFilter：这里可以写逻辑判断，是否要过滤，本文 true, 永远过滤。<br>run：过滤器的具体逻辑。可用很复杂，包括查 sql，nosql 去判断该请求到底有没有权限访问。        </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud学习4断路器（Hystrix）]]></title>
      <url>/2017/07/21/SpringCloud%E5%AD%A6%E4%B9%A04%E6%96%AD%E8%B7%AF%E5%99%A8%EF%BC%88Hystrix%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用（RPC）。为了保证其高可用，单个服务又必须集群部署。由于网络原因或者自身的原因，服务并不能保证服务的 100% 可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪，甚至导致服务 “雪崩”。<br>为了解决这个问题，就出现断路器模型。</p>
<h3 id="断路器简介"><a href="#断路器简介" class="headerlink" title="断路器简介"></a>断路器简介</h3><ul>
<li>Netflix 已经创建了一个名为 Hystrix 的库来实现断路器模式。 在微服务架构中，多层服务调用是非常常见的。</li>
<li>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用达到一个阀值（hystric 是 5 秒 20 次） 断路器将会被打开。</li>
<li>断路打开后，可用避免连锁故障，fallback 方法可以直接返回一个固定值。</li>
</ul>
<h3 id="在-ribbon-使用断路器"><a href="#在-ribbon-使用断路器" class="headerlink" title="在 ribbon 使用断路器"></a>在 ribbon 使用断路器</h3><ul>
<li><p>改造 serice-ribbon 工程的代码：</p>
<p>在 pox.xml 文件中加入：</p>
<dependency><br>     <groupid>org.springframework.cloud</groupid><br>     <artifactid>spring-cloud-starter-hystrix</artifactid><br></dependency> 
</li>
<li><p>在程序的入口类加 @EnableHystrix：   </p>
</li>
<li><p>改造 HelloService 类，加上 @HystrixCommand，并指定 fallbackMethod 方法。</p>
</li>
</ul>
<h3 id="Feign-中使用断路器"><a href="#Feign-中使用断路器" class="headerlink" title="Feign 中使用断路器"></a>Feign 中使用断路器</h3><ul>
<li><p>如果你使用了 feign，feign 是自带断路器的，并且是已经打开了。如果使用 feign 不想用断路器的话，可以在配置文件中关闭它，配置如下：</p>
<p>feign.hystrix.enabled=false</p>
</li>
</ul>
<h3 id="Circuit-Breaker-Hystrix-Dashboard-断路器：hystrix-仪表盘"><a href="#Circuit-Breaker-Hystrix-Dashboard-断路器：hystrix-仪表盘" class="headerlink" title="Circuit Breaker: Hystrix Dashboard (断路器：hystrix 仪表盘)"></a>Circuit Breaker: Hystrix Dashboard (断路器：hystrix 仪表盘)</h3><ul>
<li><p>基于 service-ribbon 改造下：</p>
<p>pom.xml 加入：</p>
<dependency><br>            <groupid>org.springframework.boot</groupid><br>            <artifactid>spring-boot-starter-actuator</artifactid><br>        </dependency>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;        
</code></pre></li>
</ul>
<h3 id="在主程序入口中加入-EnableHystrixDashboard-注解，开启-hystrixDashboard："><a href="#在主程序入口中加入-EnableHystrixDashboard-注解，开启-hystrixDashboard：" class="headerlink" title="在主程序入口中加入 @EnableHystrixDashboard 注解，开启 hystrixDashboard："></a>在主程序入口中加入 @EnableHystrixDashboard 注解，开启 hystrixDashboard：</h3><pre><code>该仪表盘可以查看错误率
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud学习3服务消费者feign]]></title>
      <url>/2017/07/21/SpringCloud%E5%AD%A6%E4%B9%A03%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85feign/</url>
      <content type="html"><![CDATA[<h3 id="使用feign"><a href="#使用feign" class="headerlink" title="使用feign"></a>使用feign</h3><p>spring-cloud-starter-eureka<br>spring-cloud-starter-feign<br>spring-boot-starter-web<br>spring-boot-starter-test</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>eureka:<br>  client:<br>    serviceUrl:<br>      defaultZone: <a href="http://localhost:8761/eureka/" target="_blank" rel="external">http://localhost:8761/eureka/</a><br>server:<br>  port: 8765<br>spring:<br>  application:<br>    name: service-feign</p>
<h3 id="开启feign"><a href="#开启feign" class="headerlink" title="开启feign"></a>开启feign</h3><ul>
<li>在程序的入口类，需要通过注解 @EnableFeignClients 来开启 feign:<h3 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h3></li>
<li>定义一个 feign 接口类, 通过 @ FeignClient（“服务名”），来指定调用哪个服务：</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud学习2服务消费者]]></title>
      <url>/2017/07/21/SpringCloud%E5%AD%A6%E4%B9%A02%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      <content type="html"><![CDATA[<p>在上一篇文章，讲了服务的注册和发现。在服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于 http restful 的。spring cloud 有两种调用方式，一种是 ribbon+restTemplate，另一种是 feign。在这一篇文章首先讲解下基于 ribbon+rest。</p>
<h2 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h2><ul>
<li><p>是一个负载均衡客户端，可以很好的控制 http 和 tcp 的一些行为。Feign 也用到 ribbon，当你使用 @ FeignClient，ribbon 自动被应用。</p>
</li>
<li><p>ribbon 已经默认实现了这些配置 bean：</p>
<ul>
<li><p>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</p>
</li>
<li><p>IRule ribbonRule: ZoneAvoidanceRule</p>
</li>
<li><p>IPing ribbonPing: NoOpPing</p>
</li>
<li><p>ServerList ribbonServerList: ConfigurationBasedServerList</p>
</li>
<li><p>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</p>
</li>
<li><p>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</p>
</li>
</ul>
</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>基于上一节的工程，启动 eureka-server 工程；启动 service-hi 工程，它的端口为 8762；将 service-hi 的配置文件的端口改为 8763, 并启动它，这时你会发现：service-hi 在 eureka-server 注册了 2 个，这就相当于一个小的集群。访问 localhost:8761 如图所示：</li>
</ul>
<h2 id="新建一个service-ribbon"><a href="#新建一个service-ribbon" class="headerlink" title="新建一个service-ribbon"></a>新建一个service-ribbon</h2><ul>
<li>spring-cloud-starter-eureka</li>
<li>spring-cloud-starter-ribbon</li>
<li>spring-boot-starter-web</li>
<li>spring-boot-starter-test</li>
</ul>
<h3 id="想eureka注册一个客户端"><a href="#想eureka注册一个客户端" class="headerlink" title="想eureka注册一个客户端"></a>想eureka注册一个客户端</h3><pre><code>eureka:
   client:
     serviceUrl:
       defaultZone: http://localhost:8761/eureka/
 server:
   port: 8764
 spring:
   application:
     name: service-ribbon  
</code></pre><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><ul>
<li>在工程的启动类中, 通过 @EnableDiscoveryClient 向服务中心注册；   </li>
</ul>
<h3 id="架构如下"><a href="#架构如下" class="headerlink" title="架构如下"></a>架构如下</h3><p>   <img src="img/ribbon后的架构.png" alt="image">      </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud学习1EurekaServer]]></title>
      <url>/2017/07/20/SpringCloud%E5%AD%A6%E4%B9%A01EurekaServer/</url>
      <content type="html"><![CDATA[<h2 id="创建EurekaServer"><a href="#创建EurekaServer" class="headerlink" title="创建EurekaServer"></a>创建EurekaServer</h2><h3 id="Idea初始化项目"><a href="#Idea初始化项目" class="headerlink" title="Idea初始化项目"></a>Idea初始化项目</h3><ul>
<li>选择cloud discovery-&gt;eureka server 。</li>
</ul>
<h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><ul>
<li>@EnableEurekaServer</li>
</ul>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><pre><code>server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre><h2 id="创建EurekaClient"><a href="#创建EurekaClient" class="headerlink" title="创建EurekaClient"></a>创建EurekaClient</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ul>
<li>通server</li>
</ul>
<h3 id="创阿金启动类"><a href="#创阿金启动类" class="headerlink" title="创阿金启动类"></a>创阿金启动类</h3><ul>
<li>@EnableEurekaClient</li>
</ul>
<h3 id="配置参数-1"><a href="#配置参数-1" class="headerlink" title="配置参数"></a>配置参数</h3><pre><code>eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
server:
  port: 8762
spring:
  application:
    name: service-hi    
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[微信公众平台Dubbo项目结构]]></title>
      <url>/2017/07/20/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0Dubbo%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"></content>
      
        
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 微信公众平台 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于微信公众号的微服务架构]]></title>
      <url>/2017/07/20/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<ul>
<li>wechatParent:    <ul>
<li>wechat-base-parent</li>
<li>wechat-business-parent</li>
<li>wechat-core-parent</li>
<li>wechat-web-parent</li>
</ul>
</li>
</ul>
<h3 id="wechatParent"><a href="#wechatParent" class="headerlink" title="wechatParent"></a>wechatParent</h3><ul>
<li>职责： 一键构建所有需要发布的项目。</li>
<li>特性<ul>
<li>所有项目初始时就带有这些 jar 包的依赖，例如：testng(单元测试相关),h2(单元测试相关),easymock(单元测试相关),lombok（根据注释自动生成 setter 和 getter）</li>
<li>所有项目的额外特性，例如：单元测试插件</li>
<li>项目发布管理，例如：私一的 maven 私服配置</li>
</ul>
</li>
</ul>
<h3 id="wechat-core-parent"><a href="#wechat-core-parent" class="headerlink" title="wechat-core-parent"></a>wechat-core-parent</h3><ul>
<li>职责：<ul>
<li>该部分与业务没有关联，只提供基础能力。例如：数据库持久能力，缓存能力，http封装能力，通用工具能力。</li>
</ul>
</li>
<li>通用特性：<ul>
<li>javadoc插件，用于生成javadoc</li>
</ul>
</li>
</ul>
<h3 id="wechat-base-parent"><a href="#wechat-base-parent" class="headerlink" title="wechat-base-parent"></a>wechat-base-parent</h3><ul>
<li>只代表一个真实存在而且能独立存在的业务实体，简称base项目。</li>
</ul>
<h3 id="we-business-parent"><a href="#we-business-parent" class="headerlink" title="we-business-parent"></a>we-business-parent</h3><ul>
<li>职责：<ul>
<li>它所聚合的的项目必须是一个提供 “共享” 业务流程，简称：business 项目。在这个流程过程中有可能需要引用 base 服务。它本身没有一个真实存在而且能独立存在的核心实体       </li>
</ul>
</li>
</ul>
<h3 id="wechat-web-parent"><a href="#wechat-web-parent" class="headerlink" title="wechat-web-parent"></a>wechat-web-parent</h3><ul>
<li>职责：<ul>
<li>它所聚合的的项目可以通过互联网向用户提供服务，在产品规划上它自己独有的不被共享的业务，简称：web 项目。</li>
</ul>
</li>
</ul>
<h3 id="总体架构图如下"><a href="#总体架构图如下" class="headerlink" title="总体架构图如下"></a>总体架构图如下</h3><p>   <img src="img/项目架构图.jpg" alt="image">  </p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>提到阿里云的这个 Redis，不得不吐槽一句，它竟然是不支持主从的，只能单实例，不过，用它做数据缓存，还真是蛮不错的选择，响应速度非常快。而且，因为是放置在内网的且只能内网访问，所以安全性也很高。<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3></li>
<li>结构型数据，主要存储档案式的数据，比如每个用户的操作行为，以档案式记录并进行统计分析，方便下一阶段的项目做个性化服务。另外一些关联复杂的数据，也可以用 MongoDb 存储，可以提高访问速度。还有，一些对软件应用版本比较敏感的数据也可以存在 MongoDB 中，比如 a 版本拿到 A 数据，b 版本拿到 B 数据，而这个 AB 数据都是由很多关联关系复杂的数据所组成，如果把这些数据根据版本号存储在不同的 MongoDB 档案中，需要时，直接根据版本号拿就可以了，这样就避免了很多的 mysql 查询。</li>
</ul>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><ul>
<li>OSS + CDN<br>OSS 存储静态资源，CDN(内容分发网络) 可以加速静态资源的下载速度。至于资源链接地址，客户端可以通过接口访问从后端业务数据库中拿到。   </li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bootstrap日期格式化]]></title>
      <url>/2017/07/18/datetimepicker%20bootstrap%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      <content type="html"><![CDATA[<ul>
<li>p : 小写上下午 (‘am’ or ‘pm’)  meridian in lower case (‘am’ or ‘pm’) - according to locale file </li>
<li>P : 大写上下午 (‘AM’ or ‘PM’) meridian in upper case (‘AM’ or ‘PM’) - according to locale file</li>
<li>s : 一位的秒  seconds without leading zeros</li>
<li>ss : 两位的秒  seconds, 2 digits with leading zeros</li>
<li>i : 一位的分钟  minutes without leading zeros</li>
<li>ii : 两位的分钟  minutes, 2 digits with leading zeros</li>
<li>h : 一位的24进制小时  hour without leading zeros - 24-hour format</li>
<li>hh : 两位的24进制小时  hour, 2 digits with leading zeros - 24-hour format</li>
<li>H : 一位的12进制小时 hour without leading zeros - 12-hour format</li>
<li>HH : 两位的24进制小时  hour, 2 digits with leading zeros - 12-hour format</li>
<li>d : 一位的天  day of the month without leading zeros</li>
<li>dd : 两位的天 day of the month, 2 digits with leading zeros</li>
<li>m : 一位的分钟  numeric representation of month without leading zeros</li>
<li>mm : 两位的分钟 numeric representation of the month, 2 digits with leading zeros</li>
<li>M : 缩写月份单词，三位数  short textual representation of a month, three letters</li>
<li>MM : 全拼月份单词 full textual representation of a month, such as January or March</li>
<li>yy : 两位的年  two digit representation of a year</li>
<li>yyyy : 四位的年  full numeric representation of a year, 4 digits</li>
</ul>
<h3 id="详情请看官网解释"><a href="#详情请看官网解释" class="headerlink" title="详情请看官网解释"></a>详情请看官网解释</h3><p><a href="http://www.bootcss.com/p/bootstrap-datetimepicker/" target="_blank" rel="external">http://www.bootcss.com/p/bootstrap-datetimepicker/</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[datetimepicker Jquery日期格式化]]></title>
      <url>/2017/07/18/datetimepicker%20Jquery%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="年"><a href="#年" class="headerlink" title="年"></a>年</h3><ul>
<li>y 一位数的年份（2001 显示为 “1”）。</li>
<li>yy 年份的最后两位数（2001 显示为 “01”）。</li>
<li>yyyy 完整的年份（2001 显示为 “2001”）。</li>
</ul>
<h3 id="月"><a href="#月" class="headerlink" title="月"></a>月</h3><ul>
<li>M 一位数或两位数月份值。</li>
<li>MM 两位数月份值。一位数数值前面加一个零。</li>
<li>MMM 三个字符的月份缩写。</li>
<li>MMMM 完整的月份名。</li>
</ul>
<h3 id="天"><a href="#天" class="headerlink" title="天"></a>天</h3><ul>
<li>d 一位数或两位数的天数。</li>
<li>dd 两位数的天数。一位数天数的前面加一个零。</li>
<li>ddd 三个字符的星期几缩写。</li>
<li>dddd 完整的星期几名称。</li>
</ul>
<h3 id="小时"><a href="#小时" class="headerlink" title="小时"></a>小时</h3><ul>
<li>h12 小时格式的一位数或两位数小时数。<br> hh12 小时格式的两位数小时数。一位数数值前面加一个零。</li>
<li>H24 小时格式的一位数或两位数小时数。</li>
<li>HH24 小时格式的两位数小时数。一位数数值前面加一个零。</li>
</ul>
<h3 id="分钟"><a href="#分钟" class="headerlink" title="分钟"></a>分钟</h3><ul>
<li>m 一位数或两位数分钟值。</li>
<li>mm 两位数分钟值。一位数数值前面加一个零。</li>
</ul>
<h3 id="秒"><a href="#秒" class="headerlink" title="秒"></a>秒</h3><ul>
<li>s 一位数或两位数秒数。</li>
<li>ss 两位数秒数。一位数数值前面加一个零。</li>
</ul>
<h3 id="上下午"><a href="#上下午" class="headerlink" title="上下午"></a>上下午</h3><ul>
<li>t 一个字母的 AM/PM 缩写（”AM” 显示为 “A”）。</li>
<li>tt 两个字母的 AM/PM 缩写（”AM” 显示为 “AM”）。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[完整写一篇博客]]></title>
      <url>/2017/07/18/%E5%AE%8C%E6%95%B4%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="1命令行创建一个md文件。"><a href="#1命令行创建一个md文件。" class="headerlink" title="1命令行创建一个md文件。"></a>1命令行创建一个md文件。</h3><ul>
<li>hexo new “title”</li>
<li><p>在 hexo 主目录下 source -&gt; _posts 新建以 .md 为后缀的文件。</p>
<p>这两种方式都可以创建一个，不过命令行形式会在md中创建描述文件：</p>
<pre><code>---
title: 完整写一篇博客
date: 2017-07-18 14:03:42
tags:
---
</code></pre></li>
</ul>
<h3 id="创建Front-matter"><a href="#创建Front-matter" class="headerlink" title="创建Front-matter"></a>创建Front-matter</h3><pre><code>参数    描述    默认值
layout    布局    post
title    标题    文件名
date    建立日期    文件建立日期
updated    更新日期    文件更新日期
tags    标签（不适用于分页）
categories    分类（不适用于分页）
permalink    覆盖文章网址
thumbnail    缩略图地址
toc    显示 TOC 按钮    true
comment    显示评论    true
notag    不生成标签按钮    false
top    置顶    false
mathJax    启用 Mathjax    false
</code></pre><h3 id="友情url链接"><a href="#友情url链接" class="headerlink" title="友情url链接"></a>友情url链接</h3><pre><code>pages:
     About:
         link: &quot;#about&quot;
         icon: person
         divider: false
</code></pre>]]></content>
      
        <categories>
            
            <category> hexo教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建Material主题的Hexo博客]]></title>
      <url>/2017/07/18/%E6%90%AD%E5%BB%BAMaterial%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>全篇可以在这搜到：</p>
<p><a href="https://material.viosey.com/services/" target="_blank" rel="external">戳这里</a></p>
<h2 id="本地搜索插件"><a href="#本地搜索插件" class="headerlink" title="本地搜索插件"></a>本地搜索插件</h2><p>npm install hexo-generator-search –save<br>在主配置文件中添加：<br>search:<br>    path: search.xml<br>    field: all</p>
<h2 id="rss订阅插件"><a href="#rss订阅插件" class="headerlink" title="rss订阅插件"></a>rss订阅插件</h2><p>npm install hexo-generator-feed –save</p>
<p>feed:<br>  type: atom<br>  path: atom.xml<br>  limit: 20<br>  hub:<br>  content:</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node8.0方法弃用解决办法]]></title>
      <url>/2017/07/18/node8-0%E6%96%B9%E6%B3%95%E5%BC%83%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="刚升级node后发现报如下的错："><a href="#刚升级node后发现报如下的错：" class="headerlink" title="刚升级node后发现报如下的错："></a>刚升级node后发现报如下的错：</h3><ul>
<li><p>(node:34880) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</p>
<p>  node.js从8.0开始已经弃用了fs.SyncWriteStream方法，hexo中有一个hexo-fs插件，调用了这个方法，所以就会报错。</p>
</li>
</ul>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ul>
<li>npm install hexo-fs –save</li>
</ul>
<p>插件就更新了，问题就解决了。</p>
]]></content>
      
        
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RPC通俗解释]]></title>
      <url>/2017/07/18/RPC%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<h1 id="RPC通俗解释"><a href="#RPC通俗解释" class="headerlink" title="RPC通俗解释"></a>RPC通俗解释</h1><h2 id="IPC和RPC"><a href="#IPC和RPC" class="headerlink" title="IPC和RPC"></a>IPC和RPC</h2><p>早些时间，一个电脑中多个线程互相独立，A线程和B线程都想用发送邮件功能，就需要开发两份代码，所以就有了一个协议是：IPC（Inter-process-communication）进行进程间通信，这样就可以在A中开发一个发送邮件的代码，B进程调用A进程代码就行了。<br>同比，现在的程序员们，为了方便调用其他电脑中的代码，研究出来RPC（Remote Procedure Call Protocol）；</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM介绍]]></title>
      <url>/2017/07/18/JVM%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="JVM介绍"><a href="#JVM介绍" class="headerlink" title="JVM介绍"></a>JVM介绍</h1><h2 id="JVM包括："><a href="#JVM包括：" class="headerlink" title="JVM包括："></a>JVM包括：</h2><pre><code>* 1、 字节码指令集
* 2、 一组寄存器
* 3、 一个栈
* 4、 一个垃圾回收堆
* 5、 存储方法区
</code></pre><h2 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h2><p>1) JVM 实例对应了一个独立运行的 java 程序它是进程级别<br>    1) 启动。启动一个 Java 程序时，一个 JVM 实例就产生了，任何一个拥有 public static void main(String[] args) 函数的 class 都可以作为 JVM 实例运行的起点<br>    2) 运行。main() 作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM 内部有两种线程：守护线程和非守护线程，main() 属于非守护线程，守护线程通常由 JVM 自己使用，<b> java 程序也可以表明自己创建的线程是守护线程 <b><br>    3) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用 Runtime 类或者 System.exit() 来退出</b></b></p>
<p>2) JVM 执行引擎实例则对应了属于用户运行程序的线程它是线程级别的</p>
<h2 id="JVM模型"><a href="#JVM模型" class="headerlink" title="JVM模型"></a>JVM模型</h2><p><img src="http://images.cnitblog.com/i/437053/201403/030952082544688.png" alt="image"></p>
<h2 id="内存空间："><a href="#内存空间：" class="headerlink" title="内存空间："></a>内存空间：</h2><pre><code>1) 方法区： 指令计数器以及其他隐含寄存器
2) Java堆： 
3) Java栈：
4) 本地方法栈：
</code></pre><h2 id="共享不共享："><a href="#共享不共享：" class="headerlink" title="共享不共享："></a>共享不共享：</h2><pre><code>共享：
    1) 方法区
    2) 栈（Heap）
不共享：
    1)程序计数器
    2)VM stack 虚拟机栈
    3)本地方法栈


1) 程序计数器： 
2) 栈： 线程私有的，每个线程创建的同时都会创建 JVM 栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及 Stack Frame，非基本类型的对象在 JVM 栈上仅存放一个指向堆上的地址。
3) 堆：1）存储 *对象实例以及数组值*
       2）**！Sun Hospot JVM为了提高对象内存分配的效率，对于所创建的线程都会分配一个独立的空间TLAB（Thread Local Allocation Buffer） ，其大小由JVM根据运行的情况计算而得，在TLAB中分配的对象不需要加锁，因此JVM在给线程的对象分配内存时会尽量在TLAB中分配，性能和C性能差不多高效，如果对象过大，仍然直接在堆中分配。 **
       3）TLAB仅作用于新生代的Eden Space，因此多个小对象比一个大对象高效。
       4）新创建的对象总是被放在新生代中，如果在一次或者多次GC后活下来，就会被转移到老年代。
4）方法区：1）在Sun JDK中对应着为永久带、持久带 ！！！
           2）方法区存放了所加载类的信息（名称，修饰符等），类中的静态变量，类中定义为final类型的常量，类中的Field信息，类中的方法信息，当开发人员用Class对象的getname,isInterface等获取信息时，数据都来源于方法区，方法区也是**共享的**，在一定条件下，也会被GC，当方法区使用的内存超过其允许的大小，也会抛OutMemory异常。
</code></pre><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><pre><code>JVM每遇到一个线程，都会为其分配一个程序计数器，VM stack 和本地方法栈，当线程终止时三者所使用的空间也被回收掉。
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何保证推送消息能够准确推送到客户端]]></title>
      <url>/2017/07/18/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E8%83%BD%E5%A4%9F%E5%87%86%E7%A1%AE%E6%8E%A8%E9%80%81%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h1 id="如何保证推送消息能够准确推送到客户端。"><a href="#如何保证推送消息能够准确推送到客户端。" class="headerlink" title="如何保证推送消息能够准确推送到客户端。"></a>如何保证推送消息能够准确推送到客户端。</h1><h2 id="手机端："><a href="#手机端：" class="headerlink" title="手机端："></a>手机端：</h2><ul>
<li>轮询方式获取消息。</li>
<li>短信拦截模式。  发送短信通知消息，应用中的短信拦截模块拦截短信，并解析成数据。成本高。</li>
<li><p>持久连接。</p>
<p>监听电量变化，网络变化，开关屏幕等等时候注册BroadCastReceiver来接收通知，接手后进行消息获取。<br>有些ROM一旦用户kill掉主线程，就不会再投送广播消息给应用，导致应用无法启动，这是可以Fork一个进程,一旦发现主线程被杀，立即调用shell启动该Service（应用保活）</p>
</li>
</ul>
<h2 id="微服务间如何选择推送和拉取数据"><a href="#微服务间如何选择推送和拉取数据" class="headerlink" title="微服务间如何选择推送和拉取数据"></a>微服务间如何选择推送和拉取数据</h2><p>在消息系统中，一般有两种消费模式：生产端推送消息，消费主动拉取消息。</p>
<h4 id="数据是动态的，且实时性较强，宜采用生产端推送。"><a href="#数据是动态的，且实时性较强，宜采用生产端推送。" class="headerlink" title="数据是动态的，且实时性较强，宜采用生产端推送。"></a>数据是动态的，且实时性较强，宜采用生产端推送。</h4><p>   例如家长手机控制孩子手机使用，希望设置立即生效，家长端设置后由<strong>立即</strong>由中间系统进行通知。如果让消费端轮询查消息，不仅不能保证消息的实时性和准确性，而且系统也会造成一定的损耗，供应链系统也会被迫处理重复订单问题。<br>    如果把消息设置成实时推送也是不合适的，<strong>推送成不成功不应该作为设置成功的条件</strong>。设置功能和推送功能不应该是强关联的，就像发送验证码，服务器收到了发送验证码的功能请求后，异步交给验证码发送功能，返回给客户200成功，随后验证码发送功能进行异步通知，确保通知成功即可。</p>
<h4 id="客户端长时间离线状态"><a href="#客户端长时间离线状态" class="headerlink" title="客户端长时间离线状态"></a>客户端长时间离线状态</h4><p>   客户端长时间离线状态（断网，没电等等），没办法推送过去，会暂存在一个暂存表中，等待客户端联网等监听广播事件进行主动获取，消息获取成功，就会把离线消息表里的消息转移到已发送的消息表中。（不在本表中将已发送的消息的字段置为已读，会影响查询速度。）</p>
<h4 id="推送的优点"><a href="#推送的优点" class="headerlink" title="推送的优点"></a>推送的优点</h4><ul>
<li>时效性高。</li>
<li>服务器压力小。 相对比轮询拉取模式，每次推送都会有数据，有效避免了空轮询</li>
<li>交互简单。 只需要提供推送接口就好了，不需要额外开销。</li>
</ul>
<h4 id="推送的缺点"><a href="#推送的缺点" class="headerlink" title="推送的缺点"></a>推送的缺点</h4><ul>
<li>不能保证一定能推送成功。</li>
<li>缺乏数据多样性，推送的消息一般都有固定的模板<br>####极光推送</li>
<li>活跃用户的到达率在90%以上。轮询获取99%以上。</li>
<li>并发情况下第三方服务的实时性不太理想。</li>
</ul>
<h4 id="自主研发的推送系统"><a href="#自主研发的推送系统" class="headerlink" title="自主研发的推送系统"></a>自主研发的推送系统</h4><ul>
<li>对客户端的海量长连接的维护管理消耗太大。</li>
<li>App端Service稳定性，保活。</li>
<li>有些厂商不允许有push service存在。</li>
</ul>
<p>##自主研发的推送架构</p>
<h3 id="架构方案类似："><a href="#架构方案类似：" class="headerlink" title="架构方案类似："></a>架构方案类似：</h3><p>   <img src="http://upload-images.jianshu.io/upload_images/1760830-e6fbb7ae6613b8ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>            （图片来自架构之美公众号，侵删）</p>
<ul>
<li>通过动态组合和扩展方式，结合移动Push推送数据分析，不同的手机使用不同的方案，针对性的优化，android平台中，融合多种不同的第三方推送PUSH平台，提高转化率。</li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[gallery]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
